{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ribbon-Tasks Ribbon-Tasks contains the Task definitions for software pipelining tool Ribbon . Usage Check out our Cookbook for instructions on how to use different Tasks. Source Code Please visit our GitHub repo for the Ribbon-Tasks source code. Ribbon-Tasks is open-source, and MIT licensed.","title":"Home"},{"location":"#ribbon-tasks","text":"Ribbon-Tasks contains the Task definitions for software pipelining tool Ribbon .","title":"Ribbon-Tasks"},{"location":"#usage","text":"Check out our Cookbook for instructions on how to use different Tasks.","title":"Usage"},{"location":"#source-code","text":"Please visit our GitHub repo for the Ribbon-Tasks source code. Ribbon-Tasks is open-source, and MIT licensed.","title":"Source Code"},{"location":"contribute/","text":"Warning \ud83d\udea7 This Page is Under Construction! \ud83d\udea7","title":"Contributing"},{"location":"cookbook/","text":"Cookbook Warning \ud83d\udea7 This page is under construction! We are still adding recipes for several Tasks . \ud83d\udea7 Chai-1 Chai-1 is a high accuracy, ligand-aware protein folding tool. It takes as input a FASTA file, and outputs a directory of folded PDB structures. Chai-1 scores are output as .npz files. Simple Fold a protein from a sequence ribbon.Chai1( fasta_file = 'my_sequence.fasta', # A single input FASTA. If there are multiple sequences, they will be folded in the same structure. output_dir = './out' # Where the outputs will be stored ).run() Advanced Fold a protein from a sequence. Include two copies of ligand ribbon.Chai1( fasta_file = 'my_sequence.fasta', # A single input FASTA. If there are multiple sequences, they will be folded in the same structure. output_dir = './out', # Where the outputs will be stored smiles_string = 'C1=CC=CC=C1', # SMILES string of our ligand num_ligands = 2, # How many copies of our ligand? device = 'gpu' # Run on GPU (necessary for Chai-1) ).run() LigandMPNN LigandMPNN is a ligand-aware tool for designing sequences for a backbone structure. It takes as input a list of PDB files, and outputs a sequence (or sequences) that are predicted to fold into that structure. While LigandMPNN is gpu-accelerated, it seems to run fast on the CPU as well. Simple Design a sequence for a backbone: ribbon.LigandMPNN( structure_list = ['my_structure.pdb'], # List of PDB files output_dir = './out' # Output directory num_designs = 5 # How many sequences should we generate? ).run() The output folder will have the following structure: output_dir/ \u251c\u2500 backbones/ # Backbone structures with labeled AAs (but no sidechains) \u251c\u2500 packed/ # (Optional) Backbone structures with packed sidechains \u251c\u2500 seqs/ # A single FASTA containing the reference sequence and all designed sequences \u2514\u2500 seqs_split/ # Individual FASTA files for each designed sequence Advanced Design a homodimeric sequence, keeping crucial residues fixed. This example uses the extra_args parameter to add extra parameters into your run command. Note that this can inject arbitrary code into your container - use with caution! ligandmpnn_task = ribbon.LigandMPNN( structure_list = ['my_structure.pdb'], # List of PDB files output_dir = './out' # Output directory num_designs = 5 # How many sequences should we generate? extra_args= '--fixed_residues \\\"' + RESIDUES_TO_KEEP + '\\\" --homo_oligomer 1' # Make sure to keep my catalytric residues, and make two chains identical. ) RaptorX-Single RaptorX-Single is a fast protein folding tool. It can fold small structures in as little as 5 seconds, after an initial loading period. It takes as input a FASTA file (or directory containing FASTAs), and outputs a directory of folded PDB structures. Simple Fold a directory of FASTA files ribbon.RaptorXSingle( fasta_file_or_dir = './my_FASTA_directory/', output_dir = './out' ).run() Advanced Fold a directory of FASTA files using a non-default model checkpoint (param). Run on the CPU (slower; GPU is default). ribbon.RaptorXSingle( fasta_file_or_dir = './my_FASTA_directory/', output_dir = './out', param = 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt', device='cpu' ).run() The available model parameters are: 'RaptorX-Single-ESM1b.pt', 'RaptorX-Single-ESM1v.pt', 'RaptorX-Single-ProtTrans.pt', 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt', 'RaptorX-Single-ESM1b-Ab.pt', 'RaptorX-Single-ESM1v-Ab.pt', 'RaptorX-Single-ProtTrans-Ab.pt', 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt'","title":"Cookbook"},{"location":"cookbook/#cookbook","text":"Warning \ud83d\udea7 This page is under construction! We are still adding recipes for several Tasks . \ud83d\udea7","title":"Cookbook"},{"location":"cookbook/#chai-1","text":"Chai-1 is a high accuracy, ligand-aware protein folding tool. It takes as input a FASTA file, and outputs a directory of folded PDB structures. Chai-1 scores are output as .npz files.","title":"Chai-1"},{"location":"cookbook/#simple","text":"Fold a protein from a sequence ribbon.Chai1( fasta_file = 'my_sequence.fasta', # A single input FASTA. If there are multiple sequences, they will be folded in the same structure. output_dir = './out' # Where the outputs will be stored ).run()","title":"Simple"},{"location":"cookbook/#advanced","text":"Fold a protein from a sequence. Include two copies of ligand ribbon.Chai1( fasta_file = 'my_sequence.fasta', # A single input FASTA. If there are multiple sequences, they will be folded in the same structure. output_dir = './out', # Where the outputs will be stored smiles_string = 'C1=CC=CC=C1', # SMILES string of our ligand num_ligands = 2, # How many copies of our ligand? device = 'gpu' # Run on GPU (necessary for Chai-1) ).run()","title":"Advanced"},{"location":"cookbook/#ligandmpnn","text":"LigandMPNN is a ligand-aware tool for designing sequences for a backbone structure. It takes as input a list of PDB files, and outputs a sequence (or sequences) that are predicted to fold into that structure. While LigandMPNN is gpu-accelerated, it seems to run fast on the CPU as well.","title":"LigandMPNN"},{"location":"cookbook/#simple_1","text":"Design a sequence for a backbone: ribbon.LigandMPNN( structure_list = ['my_structure.pdb'], # List of PDB files output_dir = './out' # Output directory num_designs = 5 # How many sequences should we generate? ).run() The output folder will have the following structure: output_dir/ \u251c\u2500 backbones/ # Backbone structures with labeled AAs (but no sidechains) \u251c\u2500 packed/ # (Optional) Backbone structures with packed sidechains \u251c\u2500 seqs/ # A single FASTA containing the reference sequence and all designed sequences \u2514\u2500 seqs_split/ # Individual FASTA files for each designed sequence","title":"Simple"},{"location":"cookbook/#advanced_1","text":"Design a homodimeric sequence, keeping crucial residues fixed. This example uses the extra_args parameter to add extra parameters into your run command. Note that this can inject arbitrary code into your container - use with caution! ligandmpnn_task = ribbon.LigandMPNN( structure_list = ['my_structure.pdb'], # List of PDB files output_dir = './out' # Output directory num_designs = 5 # How many sequences should we generate? extra_args= '--fixed_residues \\\"' + RESIDUES_TO_KEEP + '\\\" --homo_oligomer 1' # Make sure to keep my catalytric residues, and make two chains identical. )","title":"Advanced"},{"location":"cookbook/#raptorx-single","text":"RaptorX-Single is a fast protein folding tool. It can fold small structures in as little as 5 seconds, after an initial loading period. It takes as input a FASTA file (or directory containing FASTAs), and outputs a directory of folded PDB structures.","title":"RaptorX-Single"},{"location":"cookbook/#simple_2","text":"Fold a directory of FASTA files ribbon.RaptorXSingle( fasta_file_or_dir = './my_FASTA_directory/', output_dir = './out' ).run()","title":"Simple"},{"location":"cookbook/#advanced_2","text":"Fold a directory of FASTA files using a non-default model checkpoint (param). Run on the CPU (slower; GPU is default). ribbon.RaptorXSingle( fasta_file_or_dir = './my_FASTA_directory/', output_dir = './out', param = 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt', device='cpu' ).run() The available model parameters are: 'RaptorX-Single-ESM1b.pt', 'RaptorX-Single-ESM1v.pt', 'RaptorX-Single-ProtTrans.pt', 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt', 'RaptorX-Single-ESM1b-Ab.pt', 'RaptorX-Single-ESM1v-Ab.pt', 'RaptorX-Single-ProtTrans-Ab.pt', 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt'","title":"Advanced"},{"location":"customizing_tasks/","text":"Customizing Tasks You may want to add new types of Tasks to your install, or contribute to the Ribbon-Tasks repo for other users. Ribbon is built to make this process easy. Where are the Task definitions stored? By default, the Ribbon-Tasks repo is downloaded to $USER/.ribbon/ribbon_tasks . The .ribbon directory is also where you'll find the cache of submitted ribbon tasks, as well as downloaded containers. I want to install it somwhere else! If you want to create your own copy of the repo, you can download or clone the repo manually from GitHub . Then, you must set the RIBBON_TASKS_DIR environment variable to this new location using export RIBBON_TASKS_DIR=[your new location] . For this change to be saved across multiple terminal sessions, I recommend adding this line to your ~/.bashrc file - then, the change will be loaded each time you start a terminal. The Tasks were updated in GitHub! How do I update them? For now, you'll have to download the newest release , and use the above process to point Ribbon towards the new task Repo. In the future, I would like to add a Task updating feature. I want to make my own Tasks! All Tasks are defined in a simple python file and two JSON files. Please take a look at Design Notes for information on how the Tasks are defined`.","title":"Customizing your Tasks"},{"location":"customizing_tasks/#customizing-tasks","text":"You may want to add new types of Tasks to your install, or contribute to the Ribbon-Tasks repo for other users. Ribbon is built to make this process easy.","title":"Customizing Tasks"},{"location":"customizing_tasks/#where-are-the-task-definitions-stored","text":"By default, the Ribbon-Tasks repo is downloaded to $USER/.ribbon/ribbon_tasks . The .ribbon directory is also where you'll find the cache of submitted ribbon tasks, as well as downloaded containers.","title":"Where are the Task definitions stored?"},{"location":"customizing_tasks/#i-want-to-install-it-somwhere-else","text":"If you want to create your own copy of the repo, you can download or clone the repo manually from GitHub . Then, you must set the RIBBON_TASKS_DIR environment variable to this new location using export RIBBON_TASKS_DIR=[your new location] . For this change to be saved across multiple terminal sessions, I recommend adding this line to your ~/.bashrc file - then, the change will be loaded each time you start a terminal.","title":"I want to install it somwhere else!"},{"location":"customizing_tasks/#the-tasks-were-updated-in-github-how-do-i-update-them","text":"For now, you'll have to download the newest release , and use the above process to point Ribbon towards the new task Repo. In the future, I would like to add a Task updating feature.","title":"The Tasks were updated in GitHub! How do I update them?"},{"location":"customizing_tasks/#i-want-to-make-my-own-tasks","text":"All Tasks are defined in a simple python file and two JSON files. Please take a look at Design Notes for information on how the Tasks are defined`.","title":"I want to make my own Tasks!"},{"location":"design/","text":"Task Definitions What Are Ribbon Tasks? Ribbon uses a companion repository called Ribbon-Tasks , which contains the ribbon_tasks Python module. This module defines custom Task objects that Ribbon can run\u2014both locally and when queueing jobs remotely. Ribbon dynamically imports this module at runtime, allowing you to define and reuse custom tasks flexibly. To point Ribbon to your copy of the Ribbon-Tasks repo, set the $RIBBON_TASKS_DIR environment variable. For details, see Customizing Your Tasks . Structure of a Ribbon Task A Ribbon Task is defined by three components in the ribbon_tasks module: tasks.py \u2014 Python wrapper for each Task tasks.json \u2014 Defines the shell command and container to use for each Task containers.json \u2014 Maps container names to their local filenames and remote sources Let\u2019s walk through each component. 1. tasks.py : Writing the Python Wrapper Each Task is defined as a class that inherits from Task . The class must: Define __init__() to accept user inputs Set the task_name to match its entry in tasks.json Call super().__init__() to initialize the base Task class Store user inputs as instance variables Implement a run() method that calls _run_task() with named arguments Here's an example for the Chai-1 Task: Example: Chai-1 Task Class class Chai1(Task): def __init__(self, fasta_file, output_dir='.', smiles_string=None, num_ligands=1, device='gpu'): super().__init__() self.task_name = \"Chai-1\" self.fasta_file = fasta_file self.output_dir = output_dir self.smiles_string = smiles_string self.num_ligands = num_ligands self.device = device def run(self): self.output_dir = make_directory(self.output_dir) self._run_task( self.task_name, fasta_file=self.fasta_file, smiles_string=self.smiles_string, output_dir=str(self.output_dir), num_ligands=self.num_ligands, device=self.device ) Notes on _run_task() This method executes the actual job by filling in the command template from tasks.json using the provided arguments. Only variables defined in tasks.json can be passed into _run_task() . You can optionally pass an extra_args string for additional software-specific flags. Be cautious: this can inject arbitrary code if misused. Any lightweight pre/post-processing (like file creation or renaming) can also be handled in run() . For heavier logic, use a separate script and invoke it from the command string. 2. tasks.json : Defining the Command and Environment This JSON file defines each Task\u2019s metadata, including: The name and description The container to use Environment variables (if any) The shell command to run Example: Chai-1 Task Definition \"Chai-1\": { \"name\": \"Chai-1\", \"description\": \"Run Chai-1 structure prediction on a FASTA file and SMILES.\", \"container\": \"Chai-1\", \"command\": \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py {fasta_file} \\\"{smiles_string}\\\" {output_dir} --num_ligands {num_ligands} {extra_args}\", \"requirements\": \"None\", \"environment_variables\": { \"TRANSFORMERS_OFFLINE\": \"1\" } } Command String The command field is a string template. Curly-brace {} placeholders correspond to argument names passed into _run_task() . For example: _run_task(fasta_file=self.fasta_file, output_dir=self.output_dir) ...would fill in {fasta_file} and {output_dir} in the command string. Using Custom Scripts Instead of calling software directly, your command can invoke a custom Python script stored under task_scripts/<container_name>/ . For example: python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py ... $RIBBON_TASKS_MODULE_DIR is automatically set within the container to the location of the ribbon_tasks module (which is within the Ribbon-Tasks repo). This approach keeps your Task class clean while allowing complex logic to live in a dedicated script. 3. containers.json : Mapping Container Names This file maps container names to a list containing: The local .sif filename (used when the container is downloaded) The remote location (usually via ORAS / DockerHub) Example: Chai-1 Container \"Chai-1\": [ \"chai-1_0.5.2.sif\", \"oras://docker.io/nicholasfreitas/chai-1:0.5.2\" ] We recommend versioning containers explicitly to avoid compatibility issues\u2014don\u2019t use latest . Both the remote tag and local filename should reflect the version number.","title":"Task Definitions"},{"location":"design/#task-definitions","text":"","title":"Task Definitions"},{"location":"design/#what-are-ribbon-tasks","text":"Ribbon uses a companion repository called Ribbon-Tasks , which contains the ribbon_tasks Python module. This module defines custom Task objects that Ribbon can run\u2014both locally and when queueing jobs remotely. Ribbon dynamically imports this module at runtime, allowing you to define and reuse custom tasks flexibly. To point Ribbon to your copy of the Ribbon-Tasks repo, set the $RIBBON_TASKS_DIR environment variable. For details, see Customizing Your Tasks .","title":"What Are Ribbon Tasks?"},{"location":"design/#structure-of-a-ribbon-task","text":"A Ribbon Task is defined by three components in the ribbon_tasks module: tasks.py \u2014 Python wrapper for each Task tasks.json \u2014 Defines the shell command and container to use for each Task containers.json \u2014 Maps container names to their local filenames and remote sources Let\u2019s walk through each component.","title":"Structure of a Ribbon Task"},{"location":"design/#1-taskspy-writing-the-python-wrapper","text":"Each Task is defined as a class that inherits from Task . The class must: Define __init__() to accept user inputs Set the task_name to match its entry in tasks.json Call super().__init__() to initialize the base Task class Store user inputs as instance variables Implement a run() method that calls _run_task() with named arguments Here's an example for the Chai-1 Task: Example: Chai-1 Task Class class Chai1(Task): def __init__(self, fasta_file, output_dir='.', smiles_string=None, num_ligands=1, device='gpu'): super().__init__() self.task_name = \"Chai-1\" self.fasta_file = fasta_file self.output_dir = output_dir self.smiles_string = smiles_string self.num_ligands = num_ligands self.device = device def run(self): self.output_dir = make_directory(self.output_dir) self._run_task( self.task_name, fasta_file=self.fasta_file, smiles_string=self.smiles_string, output_dir=str(self.output_dir), num_ligands=self.num_ligands, device=self.device )","title":"1. tasks.py: Writing the Python Wrapper"},{"location":"design/#notes-on-_run_task","text":"This method executes the actual job by filling in the command template from tasks.json using the provided arguments. Only variables defined in tasks.json can be passed into _run_task() . You can optionally pass an extra_args string for additional software-specific flags. Be cautious: this can inject arbitrary code if misused. Any lightweight pre/post-processing (like file creation or renaming) can also be handled in run() . For heavier logic, use a separate script and invoke it from the command string.","title":"Notes on _run_task()"},{"location":"design/#2-tasksjson-defining-the-command-and-environment","text":"This JSON file defines each Task\u2019s metadata, including: The name and description The container to use Environment variables (if any) The shell command to run Example: Chai-1 Task Definition \"Chai-1\": { \"name\": \"Chai-1\", \"description\": \"Run Chai-1 structure prediction on a FASTA file and SMILES.\", \"container\": \"Chai-1\", \"command\": \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py {fasta_file} \\\"{smiles_string}\\\" {output_dir} --num_ligands {num_ligands} {extra_args}\", \"requirements\": \"None\", \"environment_variables\": { \"TRANSFORMERS_OFFLINE\": \"1\" } }","title":"2. tasks.json: Defining the Command and Environment"},{"location":"design/#command-string","text":"The command field is a string template. Curly-brace {} placeholders correspond to argument names passed into _run_task() . For example: _run_task(fasta_file=self.fasta_file, output_dir=self.output_dir) ...would fill in {fasta_file} and {output_dir} in the command string.","title":"Command String"},{"location":"design/#using-custom-scripts","text":"Instead of calling software directly, your command can invoke a custom Python script stored under task_scripts/<container_name>/ . For example: python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py ... $RIBBON_TASKS_MODULE_DIR is automatically set within the container to the location of the ribbon_tasks module (which is within the Ribbon-Tasks repo). This approach keeps your Task class clean while allowing complex logic to live in a dedicated script.","title":"Using Custom Scripts"},{"location":"design/#3-containersjson-mapping-container-names","text":"This file maps container names to a list containing: The local .sif filename (used when the container is downloaded) The remote location (usually via ORAS / DockerHub) Example: Chai-1 Container \"Chai-1\": [ \"chai-1_0.5.2.sif\", \"oras://docker.io/nicholasfreitas/chai-1:0.5.2\" ] We recommend versioning containers explicitly to avoid compatibility issues\u2014don\u2019t use latest . Both the remote tag and local filename should reflect the version number.","title":"3. containers.json: Mapping Container Names"},{"location":"design_old/","text":"Task Definitions How does Ribbon use Ribbon-Tasks? The Ribbon-Tasks repo contains the ribbon_tasks python module, which is imported at runtime by Ribbon. This dynamic import allows for flexibility - you can use the same user-defined Tasks when running manually or when queueing a job, as long as Ribbon knows where to find the Ribbon-Tasks repo. This is set using the $RIBBON_TASKS_DIR environment variable, which can be set manually. (See Customizing your Tasks ). Anatomy of a Task The ribbon_tasks module defines Tasks in 3 main components: tasks.py - contains the python wrapper code for each Task tasks.json - defines what command is run for each Task , and in which container. containers.json - defines the local name and cloud location for each container. Let's go through these one-by-one. 1. tasks.py When the user creates a Task in Ribbon, they are instantiating an object defined by a class in tasks.py . Let's take a look at the Chai-1 Class: The Chai-1 Task Class ```python class Chai1(Task): def __init__(self, fasta_file, output_dir='.', smiles_string=None, num_ligands=1, device='gpu'): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super().__init__() # This Task name matches the name in the tasks.json file self.task_name = \"Chai-1\" # Task-specific variables self.fasta_file = fasta_file self.smiles_string = smiles_string self.output_dir = output_dir self.device = device self.num_ligands = num_ligands def run(self): # Make the directory: self.output_dir = make_directory(self.output_dir) # Run the task self._run_task( self.task_name, fasta_file=self.fasta_file, smiles_string=self.smiles_string, output_dir=str(self.output_dir), num_ligands=self.num_ligands, device=self.device ) ``` As you can see, each Task definition contains two functions: the __init__() function, and the run() function. The __init()__ function must take in Task arguments, as well as initialize the parent Task class and define the Task name using the following code. # Initialize the Task class super().__init__() # This Task name matches the name in the tasks.json file self.task_name = \"Chai-1\" Finally, it must save the user arguments as object variables, which are then referenced when the Task is run: # Task-specific variables self.fasta_file = fasta_file self.smiles_string = smiles_string ... The run() function must call the self._run_task() function, passing in the user-defined object variables. _run_task() is what launches the Task by running the correct command in the container (both defined in tasks.json ). For this reason, when you pass in variables to _run_task() , the arguments names are the command arguments defined in tasks.json , which are surrounded by curly braces in the command string. Additionally, _run_task() should contain any simple helper code to run a job, including making the correct file structures, renaming output files, etc. However, if heavy python processing is required, we recommend creating a dedicated script and running that as the job itself. Finally, it's impractical to add every argument for a piece of software as an input to __init__() . For this reason, I add _run_task() excepts an extra_args input, which is a string which is often appended to the end of the command string. This allows the user to add any other software arguments as a simple string. However, this allows for the injection of arbitrary commands - so use with caution ! 2. tasks.json The tasks.json file houses a dictionary in JSON format with information on each Task, including the task name, it's container, any environment variables to pass to the job, and the command string to run inside the container. Let's take a look at the json definition for Chai-1: The Chai-1 Task Dict ```python \"Chai-1\": { \"name\": \"Chai-1\", \"description\": \"Run Chai-1 structure prediction on a FASTA file and SMILES.\", \"container\": \"Chai-1\", \"command\": \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py {fasta_file} \\\" {smiles_string} \\\" {output_dir} --num_ligands {num_ligands} {extra_args}\", \"requirements\": \"None\", \"environment_variables\": { \"TRANSFORMERS_OFFLINE\": \"1\" } }, ``` The container name points to a container in containers.json . The command string is what gets run inside the container - to pass in user variables, you surround named arguments with brackets. These arguments are digested by the Task parent class, and are used as the argument names within the _run_task() function. So, if your command looks like \"my_command {input1} {input2}\" , you'd start the task using something like _run_task( input1=self.user_input1, input2=self.user_input2 ) , where the self variables are defined in the __init__() function. Custom Scripts: - Often, the command string will run a terminal command which is already installed in the container. Sometimes, we instead write custom scripts to do a Task. For example, the Chai-1 task is run using a custom script which processess the input FASTA files into the correct format, before running the folding software using the python API. This \"heavy lifting\" should be done in a custom script to keep the Task classes lightweight and clear. - To store the custom scripts in a consistent location, we use a new directory for each container under the task_scripts directory. Place your script into the directory, and then you can reference it from the command string using something like \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py ...\" - The $RIBBON_TASKS_MODULE_DIR is automatically set within the container, and refers to the location of the ribbon_tasks folder. 3. containers.json This JSON file contains a dictionary keyed with the name of each container. Each entry in the dictionary is a list that contains the local name of the container (once it's downloaded), and the Dockerhub link (provided by oras, since we'll be downloading using the apptainer pull command under the hood). For example: \"Chai-1\": [\"chai-1_0.5.2.sif\", \"oras://docker.io/nicholasfreitas/chai-1:0.5.2\"], To maintain correct version compatibility, it's important to reference each container on Dockerhub with its specific version tag (rather than simply using latest ), and to set the local container name to similarly have this information.","title":"Task Definitions"},{"location":"design_old/#task-definitions","text":"","title":"Task Definitions"},{"location":"design_old/#how-does-ribbon-use-ribbon-tasks","text":"The Ribbon-Tasks repo contains the ribbon_tasks python module, which is imported at runtime by Ribbon. This dynamic import allows for flexibility - you can use the same user-defined Tasks when running manually or when queueing a job, as long as Ribbon knows where to find the Ribbon-Tasks repo. This is set using the $RIBBON_TASKS_DIR environment variable, which can be set manually. (See Customizing your Tasks ).","title":"How does Ribbon use Ribbon-Tasks?"},{"location":"design_old/#anatomy-of-a-task","text":"The ribbon_tasks module defines Tasks in 3 main components: tasks.py - contains the python wrapper code for each Task tasks.json - defines what command is run for each Task , and in which container. containers.json - defines the local name and cloud location for each container. Let's go through these one-by-one.","title":"Anatomy of a Task"},{"location":"design_old/#1-taskspy","text":"When the user creates a Task in Ribbon, they are instantiating an object defined by a class in tasks.py . Let's take a look at the Chai-1 Class: The Chai-1 Task Class ```python class Chai1(Task): def __init__(self, fasta_file, output_dir='.', smiles_string=None, num_ligands=1, device='gpu'): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super().__init__() # This Task name matches the name in the tasks.json file self.task_name = \"Chai-1\" # Task-specific variables self.fasta_file = fasta_file self.smiles_string = smiles_string self.output_dir = output_dir self.device = device self.num_ligands = num_ligands def run(self): # Make the directory: self.output_dir = make_directory(self.output_dir) # Run the task self._run_task( self.task_name, fasta_file=self.fasta_file, smiles_string=self.smiles_string, output_dir=str(self.output_dir), num_ligands=self.num_ligands, device=self.device ) ``` As you can see, each Task definition contains two functions: the __init__() function, and the run() function. The __init()__ function must take in Task arguments, as well as initialize the parent Task class and define the Task name using the following code. # Initialize the Task class super().__init__() # This Task name matches the name in the tasks.json file self.task_name = \"Chai-1\" Finally, it must save the user arguments as object variables, which are then referenced when the Task is run: # Task-specific variables self.fasta_file = fasta_file self.smiles_string = smiles_string ... The run() function must call the self._run_task() function, passing in the user-defined object variables. _run_task() is what launches the Task by running the correct command in the container (both defined in tasks.json ). For this reason, when you pass in variables to _run_task() , the arguments names are the command arguments defined in tasks.json , which are surrounded by curly braces in the command string. Additionally, _run_task() should contain any simple helper code to run a job, including making the correct file structures, renaming output files, etc. However, if heavy python processing is required, we recommend creating a dedicated script and running that as the job itself. Finally, it's impractical to add every argument for a piece of software as an input to __init__() . For this reason, I add _run_task() excepts an extra_args input, which is a string which is often appended to the end of the command string. This allows the user to add any other software arguments as a simple string. However, this allows for the injection of arbitrary commands - so use with caution !","title":"1. tasks.py"},{"location":"design_old/#2-tasksjson","text":"The tasks.json file houses a dictionary in JSON format with information on each Task, including the task name, it's container, any environment variables to pass to the job, and the command string to run inside the container. Let's take a look at the json definition for Chai-1: The Chai-1 Task Dict ```python \"Chai-1\": { \"name\": \"Chai-1\", \"description\": \"Run Chai-1 structure prediction on a FASTA file and SMILES.\", \"container\": \"Chai-1\", \"command\": \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py {fasta_file} \\\" {smiles_string} \\\" {output_dir} --num_ligands {num_ligands} {extra_args}\", \"requirements\": \"None\", \"environment_variables\": { \"TRANSFORMERS_OFFLINE\": \"1\" } }, ``` The container name points to a container in containers.json . The command string is what gets run inside the container - to pass in user variables, you surround named arguments with brackets. These arguments are digested by the Task parent class, and are used as the argument names within the _run_task() function. So, if your command looks like \"my_command {input1} {input2}\" , you'd start the task using something like _run_task( input1=self.user_input1, input2=self.user_input2 ) , where the self variables are defined in the __init__() function. Custom Scripts: - Often, the command string will run a terminal command which is already installed in the container. Sometimes, we instead write custom scripts to do a Task. For example, the Chai-1 task is run using a custom script which processess the input FASTA files into the correct format, before running the folding software using the python API. This \"heavy lifting\" should be done in a custom script to keep the Task classes lightweight and clear. - To store the custom scripts in a consistent location, we use a new directory for each container under the task_scripts directory. Place your script into the directory, and then you can reference it from the command string using something like \"python $RIBBON_TASKS_MODULE_DIR/task_scripts/chai-1/predict_structure.py ...\" - The $RIBBON_TASKS_MODULE_DIR is automatically set within the container, and refers to the location of the ribbon_tasks folder.","title":"2. tasks.json"},{"location":"design_old/#3-containersjson","text":"This JSON file contains a dictionary keyed with the name of each container. Each entry in the dictionary is a list that contains the local name of the container (once it's downloaded), and the Dockerhub link (provided by oras, since we'll be downloading using the apptainer pull command under the hood). For example: \"Chai-1\": [\"chai-1_0.5.2.sif\", \"oras://docker.io/nicholasfreitas/chai-1:0.5.2\"], To maintain correct version compatibility, it's important to reference each container on Dockerhub with its specific version tag (rather than simply using latest ), and to set the local container name to similarly have this information.","title":"3. containers.json"},{"location":"api/ribbon_tasks/","text":"AddHydrogens Bases: Task Source code in ribbon_tasks/tasks.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class AddHydrogens ( Task ): def __init__ ( self , input_file , output_file , selection = 'all' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: input_file (str): Path to the PDB or CIF file. output_file (str): Path to the output file. selection (str): PyMol selection string to specify what to add hydrogens to. Default is 'all'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Add Hydrogens\" # Task-specific variables self . input_file = input_file self . selection = selection self . output_file = output_file self . device = 'cpu' def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , input_file = self . input_file , output_file = self . output_file , selection = self . selection , device = self . device ) __init__ ( input_file , output_file , selection = 'all' ) Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: input_file ( str ) \u2013 Path to the PDB or CIF file. output_file ( str ) \u2013 Path to the output file. selection ( str , default: 'all' ) \u2013 PyMol selection string to specify what to add hydrogens to. Default is 'all'. Source code in ribbon_tasks/tasks.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def __init__ ( self , input_file , output_file , selection = 'all' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: input_file (str): Path to the PDB or CIF file. output_file (str): Path to the output file. selection (str): PyMol selection string to specify what to add hydrogens to. Default is 'all'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Add Hydrogens\" # Task-specific variables self . input_file = input_file self . selection = selection self . output_file = output_file self . device = 'cpu' run () Run a Task. Source code in ribbon_tasks/tasks.py 389 390 391 392 393 394 395 396 397 398 399 400 401 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , input_file = self . input_file , output_file = self . output_file , selection = self . selection , device = self . device ) CalculateDistance Bases: Task Source code in ribbon_tasks/tasks.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class CalculateDistance ( Task ): def __init__ ( self , pdb_file , atom1 , atom2 , output_file , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom1_name (str): Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name (str): Name of the second atom in the format 'Chain:Residue:Atom'. output_file (str): Path to the output file. Suffixed with '.dist'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Distance\" # Task-specific variables self . pdb_file = pdb_file self . atom1 = atom1 self . atom2 = atom2 self . output_file = output_file self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom1 = self . atom1 , atom2 = self . atom2 , output_file = self . output_file , device = self . device ) __init__ ( pdb_file , atom1 , atom2 , output_file , device = 'cpu' ) Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. atom1_name ( str ) \u2013 Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name ( str ) \u2013 Name of the second atom in the format 'Chain:Residue:Atom'. output_file ( str ) \u2013 Path to the output file. Suffixed with '.dist'. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def __init__ ( self , pdb_file , atom1 , atom2 , output_file , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom1_name (str): Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name (str): Name of the second atom in the format 'Chain:Residue:Atom'. output_file (str): Path to the output file. Suffixed with '.dist'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Distance\" # Task-specific variables self . pdb_file = pdb_file self . atom1 = atom1 self . atom2 = atom2 self . output_file = output_file self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom1 = self . atom1 , atom2 = self . atom2 , output_file = self . output_file , device = self . device ) CalculatePairwiseDistance Bases: Task Source code in ribbon_tasks/tasks.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 class CalculatePairwiseDistance ( Task ): def __init__ ( self , pdb_file , atom_list_A , atom_list_B , output_file , average = False , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom_list_A (list): List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B (list): Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file (str): Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average (bool): Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Pairwise Distance\" # Check output file extension: if not average : if Path ( output_file ) . suffix not in [ '.csv' , '.json' ]: raise ValueError ( 'Output file must be a CSV (.csv) or JSON (.json) when outputting multiple distances. \\n \\ If you want to output a single average distance, set average=True.' ) # Task-specific variables self . pdb_file = pdb_file self . atom_list_A = atom_list_A self . atom_list_B = atom_list_B self . output_file = output_file self . average = average self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) atom_group_A = \" \" . join ( self . atom_list_A ) atom_group_B = \" \" . join ( self . atom_list_B ) # Add the proper flag to the output file, # Since it depends on the file extension if self . average : self . output_file = f \"--average_output { self . output_file } \" elif Path ( self . output_file ) . suffix == '.csv' : self . output_file = f \"--csv_output { self . output_file } \" else : #json self . output_file = f \"--json_output { self . output_file } \" # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom_group_A = atom_group_A , atom_group_B = atom_group_B , output_file = self . output_file , device = self . device ) __init__ ( pdb_file , atom_list_A , atom_list_B , output_file , average = False , device = 'cpu' ) Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. atom_list_A ( list ) \u2013 List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B ( list ) \u2013 Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file ( str ) \u2013 Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average ( bool , default: False ) \u2013 Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def __init__ ( self , pdb_file , atom_list_A , atom_list_B , output_file , average = False , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom_list_A (list): List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B (list): Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file (str): Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average (bool): Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Pairwise Distance\" # Check output file extension: if not average : if Path ( output_file ) . suffix not in [ '.csv' , '.json' ]: raise ValueError ( 'Output file must be a CSV (.csv) or JSON (.json) when outputting multiple distances. \\n \\ If you want to output a single average distance, set average=True.' ) # Task-specific variables self . pdb_file = pdb_file self . atom_list_A = atom_list_A self . atom_list_B = atom_list_B self . output_file = output_file self . average = average self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) atom_group_A = \" \" . join ( self . atom_list_A ) atom_group_B = \" \" . join ( self . atom_list_B ) # Add the proper flag to the output file, # Since it depends on the file extension if self . average : self . output_file = f \"--average_output { self . output_file } \" elif Path ( self . output_file ) . suffix == '.csv' : self . output_file = f \"--csv_output { self . output_file } \" else : #json self . output_file = f \"--json_output { self . output_file } \" # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom_group_A = atom_group_A , atom_group_B = atom_group_B , output_file = self . output_file , device = self . device ) CalculateSASA Bases: Task Source code in ribbon_tasks/tasks.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class CalculateSASA ( Task ): def __init__ ( self , pdb_file , output_file , atom_1 , device = 'cpu' ): \"\"\" Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. output_file (str): Path to the output file. Suffixed with '.angle'. atom_1 (str): Atom specification in format chain_id:res_id:atom_name. device (str): The device to run the task on. Default is 'cpu'. TODO: - Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py \"\"\" raise NotImplementedError ( 'This task is not yet implemented .' ) # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate SASA\" # Task-specific variables self . pdb_file = pdb_file self . output_file = output_file self . atom_1 = atom_1 self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , output_file = self . output_file , atom_1 = self . atom_1 , device = self . device ) __init__ ( pdb_file , output_file , atom_1 , device = 'cpu' ) Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. output_file ( str ) \u2013 Path to the output file. Suffixed with '.angle'. atom_1 ( str ) \u2013 Atom specification in format chain_id:res_id:atom_name. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. TODO Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py Source code in ribbon_tasks/tasks.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def __init__ ( self , pdb_file , output_file , atom_1 , device = 'cpu' ): \"\"\" Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. output_file (str): Path to the output file. Suffixed with '.angle'. atom_1 (str): Atom specification in format chain_id:res_id:atom_name. device (str): The device to run the task on. Default is 'cpu'. TODO: - Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py \"\"\" raise NotImplementedError ( 'This task is not yet implemented .' ) # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate SASA\" # Task-specific variables self . pdb_file = pdb_file self . output_file = output_file self . atom_1 = atom_1 self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 432 433 434 435 436 437 438 439 440 441 442 443 444 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , output_file = self . output_file , atom_1 = self . atom_1 , device = self . device ) Chai1 Bases: Task Source code in ribbon_tasks/tasks.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Chai1 ( Task ): def __init__ ( self , fasta_file , output_dir = '.' , smiles_string = None , num_ligands = 1 , device = 'gpu' ): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Chai-1\" # Task-specific variables self . fasta_file = fasta_file self . smiles_string = smiles_string self . output_dir = output_dir self . device = device self . num_ligands = num_ligands def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , smiles_string = self . smiles_string , output_dir = str ( self . output_dir ), num_ligands = self . num_ligands , device = self . device ) __init__ ( fasta_file , output_dir = '.' , smiles_string = None , num_ligands = 1 , device = 'gpu' ) Initialize a Chai-1 task. Parameters: fasta_file ( str ) \u2013 The FASTA file containing the protein sequence (no ligand). output_dir ( str , default: '.' ) \u2013 The directory to save the output files. Default is '.'. smiles_string ( str , default: None ) \u2013 The SMILES string of the ligand. Default is None. num_ligands ( int , default: 1 ) \u2013 The number of ligands. Default is 1. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. Source code in ribbon_tasks/tasks.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , fasta_file , output_dir = '.' , smiles_string = None , num_ligands = 1 , device = 'gpu' ): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Chai-1\" # Task-specific variables self . fasta_file = fasta_file self . smiles_string = smiles_string self . output_dir = output_dir self . device = device self . num_ligands = num_ligands run () Run a Task. Source code in ribbon_tasks/tasks.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , smiles_string = self . smiles_string , output_dir = str ( self . output_dir ), num_ligands = self . num_ligands , device = self . device ) Custom Bases: Task Source code in ribbon_tasks/tasks.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 class Custom ( Task ): def __init__ ( self , command , container = 'Ribbon' , device = 'cpu' ): \"\"\" Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Args: command (str): The command to run. container (str): The container to run the command in. Default is 'Ribbon'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Custom\" # Task-specific variables self . command = command self . container = container self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Run the task self . _run_task ( self . task_name , command = self . command , container_override = self . container , device = self . device ) __init__ ( command , container = 'Ribbon' , device = 'cpu' ) Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Parameters: command ( str ) \u2013 The command to run. container ( str , default: 'Ribbon' ) \u2013 The container to run the command in. Default is 'Ribbon'. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def __init__ ( self , command , container = 'Ribbon' , device = 'cpu' ): \"\"\" Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Args: command (str): The command to run. container (str): The container to run the command in. Default is 'Ribbon'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Custom\" # Task-specific variables self . command = command self . container = container self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 630 631 632 633 634 635 636 637 638 639 def run ( self ): \"\"\" Run a Task. \"\"\" # Run the task self . _run_task ( self . task_name , command = self . command , container_override = self . container , device = self . device ) EasyMD Bases: Task Source code in ribbon_tasks/tasks.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 class EasyMD ( Task ): #\"command\": \"easymd run {input_file} --output {output_prefix} --duration {duration} --relax-duration {relax_duration} --output-frequency {output_frequency} {ligand_files} {forcefield_files} {water_model} {pH} {hydrogen_variants} {ionic_strength} {box_padding} {custom_bonds} {custom_angles} {custom_torsions} {minimize_only} {extra_args}\", def __init__ ( self , input_file , output_prefix , duration , relax_duration = 1 , output_frequency = 1 , ligand_files = [], forcefield_files = [ 'amber14-all.xml' , 'amber14/tip3p.xml' ], water_model = 'tip3p' , pH = 7.0 , hydrogen_variants = None , ionic_strength = 0.15 , box_padding = 1.0 , custom_bonds = [], custom_angles = [], custom_torsions = [], minimize_only = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_file (str): The input structure file. output_prefix (str): The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration (int): The duration of the simulation in nanoseconds. relax_duration (int): The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency (int): The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files (list): A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files (list): A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model (str): The water model to use. Default is 'tip3p'. pH (float): The pH of the system for protonation. Default is 7.0. hydrogen_variants (str): List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength (float): The ionic strength of the system in M. Default is 0.15 M. box_padding (float): The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds (list): List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only (bool): Whether to ONLY run a minimization, no simulation. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Returns: Outputs PDB, DCD files using the given output_prefix. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"EasyMD\" # Your arguments here: self . input_file = input_file self . output_prefix = output_prefix self . duration = duration self . relax_duration = relax_duration self . output_frequency = output_frequency self . ligand_files = \"\" . join ([ f \" -l { ligand } \" for ligand in ligand_files ]) self . forcefield_files = \" \" . join ([ f \" -f { forcefield } \" for forcefield in forcefield_files ]) self . water_model = water_model self . pH = pH self . hydrogen_variants = \" \" . join ([ f \" -hv { variant } \" for variant in hydrogen_variants ]) if hydrogen_variants else \"\" self . ionic_strength = ionic_strength self . box_padding = box_padding self . custom_bonds = \" \" . join ([ f \" -cb { bond } \" for bond in custom_bonds ]) self . custom_angles = \" \" . join ([ f \" -ca { angle } \" for angle in custom_angles ]) self . custom_torsions = \" \" . join ([ f \" -ct { torsion } \" for torsion in custom_torsions ]) self . minimize_only = \"--minimize-only\" if minimize_only else \"\" self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: Path ( self . output_prefix ) . parent . mkdir ( parents = True , exist_ok = True ) # Run the task: self . _run_task ( self . task_name , input_file = self . input_file , output_prefix = str ( self . output_prefix ), duration = self . duration , relax_duration = self . relax_duration , output_frequency = self . output_frequency , ligand_files = self . ligand_files , forcefield_files = self . forcefield_files , water_model = self . water_model , pH = self . pH , hydrogen_variants = self . hydrogen_variants , ionic_strength = self . ionic_strength , box_padding = self . box_padding , custom_bonds = self . custom_bonds , custom_angles = self . custom_angles , custom_torsions = self . custom_torsions , minimize_only = self . minimize_only , extra_args = self . extra_args , device = self . device ) return __init__ ( input_file , output_prefix , duration , relax_duration = 1 , output_frequency = 1 , ligand_files = [], forcefield_files = [ 'amber14-all.xml' , 'amber14/tip3p.xml' ], water_model = 'tip3p' , pH = 7.0 , hydrogen_variants = None , ionic_strength = 0.15 , box_padding = 1.0 , custom_bonds = [], custom_angles = [], custom_torsions = [], minimize_only = False , device = 'gpu' , extra_args = '' ) Initialize a RFDiffusionAA task. Parameters: input_file ( str ) \u2013 The input structure file. output_prefix ( str ) \u2013 The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration ( int ) \u2013 The duration of the simulation in nanoseconds. relax_duration ( int , default: 1 ) \u2013 The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency ( int , default: 1 ) \u2013 The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files ( list , default: [] ) \u2013 A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files ( list , default: ['amber14-all.xml', 'amber14/tip3p.xml'] ) \u2013 A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model ( str , default: 'tip3p' ) \u2013 The water model to use. Default is 'tip3p'. pH ( float , default: 7.0 ) \u2013 The pH of the system for protonation. Default is 7.0. hydrogen_variants ( str , default: None ) \u2013 List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength ( float , default: 0.15 ) \u2013 The ionic strength of the system in M. Default is 0.15 M. box_padding ( float , default: 1.0 ) \u2013 The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds ( list , default: [] ) \u2013 List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles ( list , default: [] ) \u2013 List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions ( list , default: [] ) \u2013 List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only ( bool , default: False ) \u2013 Whether to ONLY run a minimization, no simulation. Default is False. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Returns: \u2013 Outputs PDB, DCD files using the given output_prefix. Source code in ribbon_tasks/tasks.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def __init__ ( self , input_file , output_prefix , duration , relax_duration = 1 , output_frequency = 1 , ligand_files = [], forcefield_files = [ 'amber14-all.xml' , 'amber14/tip3p.xml' ], water_model = 'tip3p' , pH = 7.0 , hydrogen_variants = None , ionic_strength = 0.15 , box_padding = 1.0 , custom_bonds = [], custom_angles = [], custom_torsions = [], minimize_only = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_file (str): The input structure file. output_prefix (str): The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration (int): The duration of the simulation in nanoseconds. relax_duration (int): The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency (int): The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files (list): A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files (list): A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model (str): The water model to use. Default is 'tip3p'. pH (float): The pH of the system for protonation. Default is 7.0. hydrogen_variants (str): List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength (float): The ionic strength of the system in M. Default is 0.15 M. box_padding (float): The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds (list): List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only (bool): Whether to ONLY run a minimization, no simulation. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Returns: Outputs PDB, DCD files using the given output_prefix. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"EasyMD\" # Your arguments here: self . input_file = input_file self . output_prefix = output_prefix self . duration = duration self . relax_duration = relax_duration self . output_frequency = output_frequency self . ligand_files = \"\" . join ([ f \" -l { ligand } \" for ligand in ligand_files ]) self . forcefield_files = \" \" . join ([ f \" -f { forcefield } \" for forcefield in forcefield_files ]) self . water_model = water_model self . pH = pH self . hydrogen_variants = \" \" . join ([ f \" -hv { variant } \" for variant in hydrogen_variants ]) if hydrogen_variants else \"\" self . ionic_strength = ionic_strength self . box_padding = box_padding self . custom_bonds = \" \" . join ([ f \" -cb { bond } \" for bond in custom_bonds ]) self . custom_angles = \" \" . join ([ f \" -ca { angle } \" for angle in custom_angles ]) self . custom_torsions = \" \" . join ([ f \" -ct { torsion } \" for torsion in custom_torsions ]) self . minimize_only = \"--minimize-only\" if minimize_only else \"\" self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: Path ( self . output_prefix ) . parent . mkdir ( parents = True , exist_ok = True ) # Run the task: self . _run_task ( self . task_name , input_file = self . input_file , output_prefix = str ( self . output_prefix ), duration = self . duration , relax_duration = self . relax_duration , output_frequency = self . output_frequency , ligand_files = self . ligand_files , forcefield_files = self . forcefield_files , water_model = self . water_model , pH = self . pH , hydrogen_variants = self . hydrogen_variants , ionic_strength = self . ionic_strength , box_padding = self . box_padding , custom_bonds = self . custom_bonds , custom_angles = self . custom_angles , custom_torsions = self . custom_torsions , minimize_only = self . minimize_only , extra_args = self . extra_args , device = self . device ) return FastRelax Bases: Task Source code in ribbon_tasks/tasks.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class FastRelax ( Task ): def __init__ ( self , output_dir , pdb_input_file = None , pdb_input_dir = None , device = 'cpu' ): \"\"\" Initialize a FastRelax task. Args: output_dir (str): The directory to save the output files. pdb_input_file (str, optional): Path to a single PDB file. Default is None. pdb_input_dir (str, optional): Path to a directory containing PDB files. Default is None. device (str): The device to run the task on. Default is 'cpu'. Raises: ValueError: If neither pdb_input_file nor pdb_input_dir is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"FastRelax\" # Task-specific variables if pdb_input_file is None and pdb_input_dir is None : raise ValueError ( 'Must specify either pdb_input_file or pdb_input_dir' ) self . output_dir = make_directory ( output_dir ) self . pdb_input_file = pdb_input_file self . pdb_input_dir = pdb_input_dir self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Handle input files if self . pdb_input_file is not None : temp_dir = tempfile . mkdtemp () shutil . copy ( self . pdb_input_file , temp_dir ) pdb_input_dir = temp_dir else : pdb_input_dir = self . pdb_input_dir # Prepare PDB files pdb_list = list_files ( pdb_input_dir , '.pdb' ) pdb_string = \" \" . join ( map ( str , pdb_list )) + \" \" # Run the task self . _run_task ( self . task_name , pdb_string = pdb_string , output_dir = str ( self . output_dir ), device = self . device ) __init__ ( output_dir , pdb_input_file = None , pdb_input_dir = None , device = 'cpu' ) Initialize a FastRelax task. Parameters: output_dir ( str ) \u2013 The directory to save the output files. pdb_input_file ( str , default: None ) \u2013 Path to a single PDB file. Default is None. pdb_input_dir ( str , default: None ) \u2013 Path to a directory containing PDB files. Default is None. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Raises: ValueError \u2013 If neither pdb_input_file nor pdb_input_dir is specified. Source code in ribbon_tasks/tasks.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , output_dir , pdb_input_file = None , pdb_input_dir = None , device = 'cpu' ): \"\"\" Initialize a FastRelax task. Args: output_dir (str): The directory to save the output files. pdb_input_file (str, optional): Path to a single PDB file. Default is None. pdb_input_dir (str, optional): Path to a directory containing PDB files. Default is None. device (str): The device to run the task on. Default is 'cpu'. Raises: ValueError: If neither pdb_input_file nor pdb_input_dir is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"FastRelax\" # Task-specific variables if pdb_input_file is None and pdb_input_dir is None : raise ValueError ( 'Must specify either pdb_input_file or pdb_input_dir' ) self . output_dir = make_directory ( output_dir ) self . pdb_input_file = pdb_input_file self . pdb_input_dir = pdb_input_dir self . device = device run () Run a Task. Source code in ribbon_tasks/tasks.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def run ( self ): \"\"\" Run a Task. \"\"\" # Handle input files if self . pdb_input_file is not None : temp_dir = tempfile . mkdtemp () shutil . copy ( self . pdb_input_file , temp_dir ) pdb_input_dir = temp_dir else : pdb_input_dir = self . pdb_input_dir # Prepare PDB files pdb_list = list_files ( pdb_input_dir , '.pdb' ) pdb_string = \" \" . join ( map ( str , pdb_list )) + \" \" # Run the task self . _run_task ( self . task_name , pdb_string = pdb_string , output_dir = str ( self . output_dir ), device = self . device ) LigandMPNN Bases: Task Source code in ribbon_tasks/tasks.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class LigandMPNN ( Task ): def __init__ ( self , output_dir , structure_list , num_designs = 1 , device = 'cpu' , extra_args = \"\" ): \"\"\" Initialize a LigandMPNN task. Args: output_dir (str): The directory to save the output files. structure_list (list): A list of pdb or cif files to use as input structures. num_designs (int): The number of designs to generate per input structure. device (str): The device to run the task on. Default is 'cpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"LigandMPNN\" # Your arguments here: self . output_dir = output_dir self . structure_list = structure_list self . num_designs = num_designs def run ( self ): \"\"\" Run a Task. \"\"\" ###### HELPER FUNCTIONS ####### def split_ligandmpnn_fasta ( fasta_file , split_output_dir ): # Each LigandMPNN input produces a FASTA with multiple outputs as > lines. Each line has 1 or more chains separated by ':'. # Here, we separate each output into it's own FASTA file, with chains as separate > lines. split_output_dir . mkdir ( parents = True , exist_ok = True ) with open ( fasta_file ) as f : # Skip the first two lines (original input) lines = f . readlines ()[ 2 :] for i in range ( 0 , len ( lines ), 2 ): if not lines [ i ] . startswith ( '>' ): continue name = lines [ i ] . strip () chains = lines [ i + 1 ] . strip () . split ( ':' ) index = 0 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' # Increment the index to avoid overwriting existing files while output_path . exists (): index += 1 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' print ( f 'Writing to { output_path } ' ) with open ( output_path , 'w' ) as g : for chain_index , chain in enumerate ( chains ): name_with_chain = f \" { name . split ( ',' )[ 0 ] } _ { chain_index } \" + ', ' + ',' . join ( name . split ( ',' )[ 1 :]) # Add chain to name g . write ( f ' { name_with_chain } \\n { chain } \\n ' ) # Make directories: self . output_dir = make_directory ( self . output_dir ) # Then, write out the files within pdb_input_dir to a json file: #pdb_input_json = self.output_dir / 'pdb_input.json' # Make a temp file for the json: pdb_input_json = tempfile . NamedTemporaryFile ( delete = False ) . name with open ( pdb_input_json , 'w' ) as f : json . dump ( self . structure_list , f ) # Run the task: self . _run_task ( self . task_name , pdb_input_json = pdb_input_json , output_dir = self . output_dir , num_designs = self . num_designs , extra_args = self . extra_args , device = self . device ) # Split the FASTA files: for file in ( self . output_dir / 'seqs' ) . iterdir (): print ( f 'Splitting { file } ' ) split_ligandmpnn_fasta ( file , self . output_dir / 'seqs_split' ) return __init__ ( output_dir , structure_list , num_designs = 1 , device = 'cpu' , extra_args = '' ) Initialize a LigandMPNN task. Parameters: output_dir ( str ) \u2013 The directory to save the output files. structure_list ( list ) \u2013 A list of pdb or cif files to use as input structures. num_designs ( int , default: 1 ) \u2013 The number of designs to generate per input structure. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Returns: \u2013 None \u2013 Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. Source code in ribbon_tasks/tasks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , output_dir , structure_list , num_designs = 1 , device = 'cpu' , extra_args = \"\" ): \"\"\" Initialize a LigandMPNN task. Args: output_dir (str): The directory to save the output files. structure_list (list): A list of pdb or cif files to use as input structures. num_designs (int): The number of designs to generate per input structure. device (str): The device to run the task on. Default is 'cpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"LigandMPNN\" # Your arguments here: self . output_dir = output_dir self . structure_list = structure_list self . num_designs = num_designs run () Run a Task. Source code in ribbon_tasks/tasks.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def run ( self ): \"\"\" Run a Task. \"\"\" ###### HELPER FUNCTIONS ####### def split_ligandmpnn_fasta ( fasta_file , split_output_dir ): # Each LigandMPNN input produces a FASTA with multiple outputs as > lines. Each line has 1 or more chains separated by ':'. # Here, we separate each output into it's own FASTA file, with chains as separate > lines. split_output_dir . mkdir ( parents = True , exist_ok = True ) with open ( fasta_file ) as f : # Skip the first two lines (original input) lines = f . readlines ()[ 2 :] for i in range ( 0 , len ( lines ), 2 ): if not lines [ i ] . startswith ( '>' ): continue name = lines [ i ] . strip () chains = lines [ i + 1 ] . strip () . split ( ':' ) index = 0 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' # Increment the index to avoid overwriting existing files while output_path . exists (): index += 1 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' print ( f 'Writing to { output_path } ' ) with open ( output_path , 'w' ) as g : for chain_index , chain in enumerate ( chains ): name_with_chain = f \" { name . split ( ',' )[ 0 ] } _ { chain_index } \" + ', ' + ',' . join ( name . split ( ',' )[ 1 :]) # Add chain to name g . write ( f ' { name_with_chain } \\n { chain } \\n ' ) # Make directories: self . output_dir = make_directory ( self . output_dir ) # Then, write out the files within pdb_input_dir to a json file: #pdb_input_json = self.output_dir / 'pdb_input.json' # Make a temp file for the json: pdb_input_json = tempfile . NamedTemporaryFile ( delete = False ) . name with open ( pdb_input_json , 'w' ) as f : json . dump ( self . structure_list , f ) # Run the task: self . _run_task ( self . task_name , pdb_input_json = pdb_input_json , output_dir = self . output_dir , num_designs = self . num_designs , extra_args = self . extra_args , device = self . device ) # Split the FASTA files: for file in ( self . output_dir / 'seqs' ) . iterdir (): print ( f 'Splitting { file } ' ) split_ligandmpnn_fasta ( file , self . output_dir / 'seqs_split' ) return RFDiffusionAA Bases: Task Source code in ribbon_tasks/tasks.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 class RFDiffusionAA ( Task ): def __init__ ( self , input_structure , output_dir , contig_map , num_designs = 1 , total_length = 'null' , ligand = 'null' , diffuser_steps = 200 , deterministic = False , design_startnum = 0 , force = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_structure (str): The input structure file. output_dir (str): The directory to save the output files. contig_map (str): The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs (int): The number of designs to generate per input structure. total_length (str): The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand (str): The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps (int): The number of steps to run the diffuser for. Default is 200. deterministic (bool): Whether to use a deterministic seed for the diffuser. Default is False. design_startnum (int): The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force (bool): Whether to overwrite existing output files. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs designs in the output_dir. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"RFDiffusionAA\" # Your arguments here: self . input_structure = input_structure self . output_dir = output_dir self . contig_map = contig_map self . num_designs = num_designs self . total_length = total_length self . ligand = ligand self . diffuser_steps = diffuser_steps self . deterministic = deterministic self . design_startnum = design_startnum self . force = force # we should have a final length flag for config.length def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: self . output_dir = make_directory ( self . output_dir ) # Convert the output_dir to a prefix: output_prefix = Path ( self . output_dir ) / 'design' # Run the task: self . _run_task ( self . task_name , input_structure = self . input_structure , output_prefix = str ( output_prefix ), # we provide a prefix (e.g. ./out/sample) instead of dir (e.g. ./out) contig_map = self . contig_map , num_designs = self . num_designs , total_length = self . total_length , ligand = self . ligand , diffuser_steps = self . diffuser_steps , deterministic = self . deterministic , design_startnum = self . design_startnum , cautious = not self . force , # If force is True, then we overwrite existing files extra_args = self . extra_args , device = self . device ) return __init__ ( input_structure , output_dir , contig_map , num_designs = 1 , total_length = 'null' , ligand = 'null' , diffuser_steps = 200 , deterministic = False , design_startnum = 0 , force = False , device = 'gpu' , extra_args = '' ) Initialize a RFDiffusionAA task. Parameters: input_structure ( str ) \u2013 The input structure file. output_dir ( str ) \u2013 The directory to save the output files. contig_map ( str ) \u2013 The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs ( int , default: 1 ) \u2013 The number of designs to generate per input structure. total_length ( str , default: 'null' ) \u2013 The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand ( str , default: 'null' ) \u2013 The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps ( int , default: 200 ) \u2013 The number of steps to run the diffuser for. Default is 200. deterministic ( bool , default: False ) \u2013 Whether to use a deterministic seed for the diffuser. Default is False. design_startnum ( int , default: 0 ) \u2013 The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force ( bool , default: False ) \u2013 Whether to overwrite existing output files. Default is False. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Returns: \u2013 None \u2013 Outputs designs in the output_dir. Source code in ribbon_tasks/tasks.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def __init__ ( self , input_structure , output_dir , contig_map , num_designs = 1 , total_length = 'null' , ligand = 'null' , diffuser_steps = 200 , deterministic = False , design_startnum = 0 , force = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_structure (str): The input structure file. output_dir (str): The directory to save the output files. contig_map (str): The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs (int): The number of designs to generate per input structure. total_length (str): The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand (str): The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps (int): The number of steps to run the diffuser for. Default is 200. deterministic (bool): Whether to use a deterministic seed for the diffuser. Default is False. design_startnum (int): The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force (bool): Whether to overwrite existing output files. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs designs in the output_dir. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"RFDiffusionAA\" # Your arguments here: self . input_structure = input_structure self . output_dir = output_dir self . contig_map = contig_map self . num_designs = num_designs self . total_length = total_length self . ligand = ligand self . diffuser_steps = diffuser_steps self . deterministic = deterministic self . design_startnum = design_startnum self . force = force run () Run a Task. Source code in ribbon_tasks/tasks.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: self . output_dir = make_directory ( self . output_dir ) # Convert the output_dir to a prefix: output_prefix = Path ( self . output_dir ) / 'design' # Run the task: self . _run_task ( self . task_name , input_structure = self . input_structure , output_prefix = str ( output_prefix ), # we provide a prefix (e.g. ./out/sample) instead of dir (e.g. ./out) contig_map = self . contig_map , num_designs = self . num_designs , total_length = self . total_length , ligand = self . ligand , diffuser_steps = self . diffuser_steps , deterministic = self . deterministic , design_startnum = self . design_startnum , cautious = not self . force , # If force is True, then we overwrite existing files extra_args = self . extra_args , device = self . device ) return RaptorXSingle Bases: Task Source code in ribbon_tasks/tasks.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class RaptorXSingle ( Task ): def __init__ ( self , fasta_file_or_dir , output_dir = '.' , param = 'RaptorX-Single-ESM1b.pt' , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RaptorXSingle task. Args: fasta_file_or_dir (str): The FASTA file or directory containing multiple FASTA files. output_dir (str): The directory to save the output files. Default is '.'. param (str): The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Raises: ValueError: If an invalid param is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"RaptorXSingle\" # Task-specific variables self . fasta_file = fasta_file_or_dir self . output_dir = output_dir self . param = 'RaptorX-Single/params/' + param #This is the directory where the params are stored self . extra_args = extra_args self . device = device if device == 'gpu' : self . device_id = '0' elif device == 'cpu' : self . device_id = '-1' else : self . device_id = str ( device ) self . device = 'cpu' if device == '-1' else 'gpu' # Check inputs: valid_param_list = [ 'RaptorX-Single-ESM1b.pt' , 'RaptorX-Single-ESM1v.pt' , 'RaptorX-Single-ProtTrans.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt' , 'RaptorX-Single-ESM1b-Ab.pt' , 'RaptorX-Single-ESM1v-Ab.pt' , 'RaptorX-Single-ProtTrans-Ab.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt' ] if param not in valid_param_list : raise ValueError ( f 'Invalid param: { param } . Must be one of { valid_param_list } ' ) def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # \"python RaptorX-Single/pred.py {fasta_file} RaptorX-Single/params/{param} --plm_param_dir RaptorX-Single/params/ --out_dir {output_dir} --device {device} {extra_args}\", # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , param = self . param , output_dir = str ( self . output_dir ), device = self . device , device_id = self . device_id , extra_args = self . extra_args ) __init__ ( fasta_file_or_dir , output_dir = '.' , param = 'RaptorX-Single-ESM1b.pt' , device = 'gpu' , extra_args = '' ) Initialize a RaptorXSingle task. Parameters: fasta_file_or_dir ( str ) \u2013 The FASTA file or directory containing multiple FASTA files. output_dir ( str , default: '.' ) \u2013 The directory to save the output files. Default is '.'. param ( str , default: 'RaptorX-Single-ESM1b.pt' ) \u2013 The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Raises: ValueError \u2013 If an invalid param is specified. Source code in ribbon_tasks/tasks.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def __init__ ( self , fasta_file_or_dir , output_dir = '.' , param = 'RaptorX-Single-ESM1b.pt' , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RaptorXSingle task. Args: fasta_file_or_dir (str): The FASTA file or directory containing multiple FASTA files. output_dir (str): The directory to save the output files. Default is '.'. param (str): The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Raises: ValueError: If an invalid param is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"RaptorXSingle\" # Task-specific variables self . fasta_file = fasta_file_or_dir self . output_dir = output_dir self . param = 'RaptorX-Single/params/' + param #This is the directory where the params are stored self . extra_args = extra_args self . device = device if device == 'gpu' : self . device_id = '0' elif device == 'cpu' : self . device_id = '-1' else : self . device_id = str ( device ) self . device = 'cpu' if device == '-1' else 'gpu' # Check inputs: valid_param_list = [ 'RaptorX-Single-ESM1b.pt' , 'RaptorX-Single-ESM1v.pt' , 'RaptorX-Single-ProtTrans.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt' , 'RaptorX-Single-ESM1b-Ab.pt' , 'RaptorX-Single-ESM1v-Ab.pt' , 'RaptorX-Single-ProtTrans-Ab.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt' ] if param not in valid_param_list : raise ValueError ( f 'Invalid param: { param } . Must be one of { valid_param_list } ' ) run () Run a Task. Source code in ribbon_tasks/tasks.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # \"python RaptorX-Single/pred.py {fasta_file} RaptorX-Single/params/{param} --plm_param_dir RaptorX-Single/params/ --out_dir {output_dir} --device {device} {extra_args}\", # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , param = self . param , output_dir = str ( self . output_dir ), device = self . device , device_id = self . device_id , extra_args = self . extra_args )","title":"Ribbon Tasks"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.AddHydrogens","text":"Bases: Task Source code in ribbon_tasks/tasks.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class AddHydrogens ( Task ): def __init__ ( self , input_file , output_file , selection = 'all' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: input_file (str): Path to the PDB or CIF file. output_file (str): Path to the output file. selection (str): PyMol selection string to specify what to add hydrogens to. Default is 'all'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Add Hydrogens\" # Task-specific variables self . input_file = input_file self . selection = selection self . output_file = output_file self . device = 'cpu' def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , input_file = self . input_file , output_file = self . output_file , selection = self . selection , device = self . device )","title":"AddHydrogens"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.AddHydrogens.__init__","text":"Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: input_file ( str ) \u2013 Path to the PDB or CIF file. output_file ( str ) \u2013 Path to the output file. selection ( str , default: 'all' ) \u2013 PyMol selection string to specify what to add hydrogens to. Default is 'all'. Source code in ribbon_tasks/tasks.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def __init__ ( self , input_file , output_file , selection = 'all' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: input_file (str): Path to the PDB or CIF file. output_file (str): Path to the output file. selection (str): PyMol selection string to specify what to add hydrogens to. Default is 'all'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Add Hydrogens\" # Task-specific variables self . input_file = input_file self . selection = selection self . output_file = output_file self . device = 'cpu'","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.AddHydrogens.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 389 390 391 392 393 394 395 396 397 398 399 400 401 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , input_file = self . input_file , output_file = self . output_file , selection = self . selection , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateDistance","text":"Bases: Task Source code in ribbon_tasks/tasks.py 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class CalculateDistance ( Task ): def __init__ ( self , pdb_file , atom1 , atom2 , output_file , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom1_name (str): Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name (str): Name of the second atom in the format 'Chain:Residue:Atom'. output_file (str): Path to the output file. Suffixed with '.dist'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Distance\" # Task-specific variables self . pdb_file = pdb_file self . atom1 = atom1 self . atom2 = atom2 self . output_file = output_file self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom1 = self . atom1 , atom2 = self . atom2 , output_file = self . output_file , device = self . device )","title":"CalculateDistance"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateDistance.__init__","text":"Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. atom1_name ( str ) \u2013 Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name ( str ) \u2013 Name of the second atom in the format 'Chain:Residue:Atom'. output_file ( str ) \u2013 Path to the output file. Suffixed with '.dist'. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def __init__ ( self , pdb_file , atom1 , atom2 , output_file , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom1_name (str): Name of the first atom in the format 'Chain:Residue:Atom'. atom2_name (str): Name of the second atom in the format 'Chain:Residue:Atom'. output_file (str): Path to the output file. Suffixed with '.dist'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Distance\" # Task-specific variables self . pdb_file = pdb_file self . atom1 = atom1 self . atom2 = atom2 self . output_file = output_file self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateDistance.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom1 = self . atom1 , atom2 = self . atom2 , output_file = self . output_file , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculatePairwiseDistance","text":"Bases: Task Source code in ribbon_tasks/tasks.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 class CalculatePairwiseDistance ( Task ): def __init__ ( self , pdb_file , atom_list_A , atom_list_B , output_file , average = False , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom_list_A (list): List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B (list): Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file (str): Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average (bool): Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Pairwise Distance\" # Check output file extension: if not average : if Path ( output_file ) . suffix not in [ '.csv' , '.json' ]: raise ValueError ( 'Output file must be a CSV (.csv) or JSON (.json) when outputting multiple distances. \\n \\ If you want to output a single average distance, set average=True.' ) # Task-specific variables self . pdb_file = pdb_file self . atom_list_A = atom_list_A self . atom_list_B = atom_list_B self . output_file = output_file self . average = average self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) atom_group_A = \" \" . join ( self . atom_list_A ) atom_group_B = \" \" . join ( self . atom_list_B ) # Add the proper flag to the output file, # Since it depends on the file extension if self . average : self . output_file = f \"--average_output { self . output_file } \" elif Path ( self . output_file ) . suffix == '.csv' : self . output_file = f \"--csv_output { self . output_file } \" else : #json self . output_file = f \"--json_output { self . output_file } \" # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom_group_A = atom_group_A , atom_group_B = atom_group_B , output_file = self . output_file , device = self . device )","title":"CalculatePairwiseDistance"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculatePairwiseDistance.__init__","text":"Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. atom_list_A ( list ) \u2013 List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B ( list ) \u2013 Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file ( str ) \u2013 Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average ( bool , default: False ) \u2013 Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def __init__ ( self , pdb_file , atom_list_A , atom_list_B , output_file , average = False , device = 'cpu' ): \"\"\" Initialize a CalculateDistance task. This calculates the distance between two atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. atom_list_A (list): List of atoms in the first group in the format [ 'Chain:Residue:Atom', ...]. atom_list_B (list): Name of the second atom in the format [ 'Chain:Residue:Atom', ...]. output_file (str): Path to the output file. Must be a CSV (.csv) or JSON (.json). CSV has the columns: \"A_index\", \"AtomA\", \"B_index\", \"AtomB\", \"Distance\". JSON is a list of dicts with keys: \"A_index\", \"A_spec\", \"B_index\", \"B_spec\", \"distance\" average (bool): Whether to return the average distance. Default is False. If True, the output file will contain a single value (no other information). device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate Pairwise Distance\" # Check output file extension: if not average : if Path ( output_file ) . suffix not in [ '.csv' , '.json' ]: raise ValueError ( 'Output file must be a CSV (.csv) or JSON (.json) when outputting multiple distances. \\n \\ If you want to output a single average distance, set average=True.' ) # Task-specific variables self . pdb_file = pdb_file self . atom_list_A = atom_list_A self . atom_list_B = atom_list_B self . output_file = output_file self . average = average self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculatePairwiseDistance.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) atom_group_A = \" \" . join ( self . atom_list_A ) atom_group_B = \" \" . join ( self . atom_list_B ) # Add the proper flag to the output file, # Since it depends on the file extension if self . average : self . output_file = f \"--average_output { self . output_file } \" elif Path ( self . output_file ) . suffix == '.csv' : self . output_file = f \"--csv_output { self . output_file } \" else : #json self . output_file = f \"--json_output { self . output_file } \" # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , atom_group_A = atom_group_A , atom_group_B = atom_group_B , output_file = self . output_file , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateSASA","text":"Bases: Task Source code in ribbon_tasks/tasks.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 class CalculateSASA ( Task ): def __init__ ( self , pdb_file , output_file , atom_1 , device = 'cpu' ): \"\"\" Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. output_file (str): Path to the output file. Suffixed with '.angle'. atom_1 (str): Atom specification in format chain_id:res_id:atom_name. device (str): The device to run the task on. Default is 'cpu'. TODO: - Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py \"\"\" raise NotImplementedError ( 'This task is not yet implemented .' ) # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate SASA\" # Task-specific variables self . pdb_file = pdb_file self . output_file = output_file self . atom_1 = atom_1 self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , output_file = self . output_file , atom_1 = self . atom_1 , device = self . device )","title":"CalculateSASA"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateSASA.__init__","text":"Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Parameters: pdb_file ( str ) \u2013 Path to the PDB file. output_file ( str ) \u2013 Path to the output file. Suffixed with '.angle'. atom_1 ( str ) \u2013 Atom specification in format chain_id:res_id:atom_name. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. TODO Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py Source code in ribbon_tasks/tasks.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def __init__ ( self , pdb_file , output_file , atom_1 , device = 'cpu' ): \"\"\" Initialize a CalculateSASA task. This calculates the Solvent Accessible Surface Area for a set of atoms in a PDB file. Args: pdb_file (str): Path to the PDB file. output_file (str): Path to the output file. Suffixed with '.angle'. atom_1 (str): Atom specification in format chain_id:res_id:atom_name. device (str): The device to run the task on. Default is 'cpu'. TODO: - Implement the task script in ribbon/ribbon_tasks/task_scripts/calculate_sasa.py \"\"\" raise NotImplementedError ( 'This task is not yet implemented .' ) # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Calculate SASA\" # Task-specific variables self . pdb_file = pdb_file self . output_file = output_file self . atom_1 = atom_1 self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.CalculateSASA.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 432 433 434 435 436 437 438 439 440 441 442 443 444 def run ( self ): \"\"\" Run a Task. \"\"\" # Ensure output directory exists make_directory ( Path ( self . output_file ) . parent ) # Run the task self . _run_task ( self . task_name , pdb_file = self . pdb_file , output_file = self . output_file , atom_1 = self . atom_1 , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Chai1","text":"Bases: Task Source code in ribbon_tasks/tasks.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Chai1 ( Task ): def __init__ ( self , fasta_file , output_dir = '.' , smiles_string = None , num_ligands = 1 , device = 'gpu' ): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Chai-1\" # Task-specific variables self . fasta_file = fasta_file self . smiles_string = smiles_string self . output_dir = output_dir self . device = device self . num_ligands = num_ligands def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , smiles_string = self . smiles_string , output_dir = str ( self . output_dir ), num_ligands = self . num_ligands , device = self . device )","title":"Chai1"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Chai1.__init__","text":"Initialize a Chai-1 task. Parameters: fasta_file ( str ) \u2013 The FASTA file containing the protein sequence (no ligand). output_dir ( str , default: '.' ) \u2013 The directory to save the output files. Default is '.'. smiles_string ( str , default: None ) \u2013 The SMILES string of the ligand. Default is None. num_ligands ( int , default: 1 ) \u2013 The number of ligands. Default is 1. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. Source code in ribbon_tasks/tasks.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , fasta_file , output_dir = '.' , smiles_string = None , num_ligands = 1 , device = 'gpu' ): \"\"\" Initialize a Chai-1 task. Args: fasta_file (str): The FASTA file containing the protein sequence (no ligand). output_dir (str): The directory to save the output files. Default is '.'. smiles_string (str, optional): The SMILES string of the ligand. Default is None. num_ligands (int): The number of ligands. Default is 1. device (str): The device to run the task on. Default is 'gpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Chai-1\" # Task-specific variables self . fasta_file = fasta_file self . smiles_string = smiles_string self . output_dir = output_dir self . device = device self . num_ligands = num_ligands","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Chai1.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , smiles_string = self . smiles_string , output_dir = str ( self . output_dir ), num_ligands = self . num_ligands , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Custom","text":"Bases: Task Source code in ribbon_tasks/tasks.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 class Custom ( Task ): def __init__ ( self , command , container = 'Ribbon' , device = 'cpu' ): \"\"\" Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Args: command (str): The command to run. container (str): The container to run the command in. Default is 'Ribbon'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Custom\" # Task-specific variables self . command = command self . container = container self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Run the task self . _run_task ( self . task_name , command = self . command , container_override = self . container , device = self . device )","title":"Custom"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Custom.__init__","text":"Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Parameters: command ( str ) \u2013 The command to run. container ( str , default: 'Ribbon' ) \u2013 The container to run the command in. Default is 'Ribbon'. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Source code in ribbon_tasks/tasks.py 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def __init__ ( self , command , container = 'Ribbon' , device = 'cpu' ): \"\"\" Initialize a Custom task. This allows the user to run a custom command in a specified container. N.B. This allows the user to run arbitrary code; use with caution. Args: command (str): The command to run. container (str): The container to run the command in. Default is 'Ribbon'. device (str): The device to run the task on. Default is 'cpu'. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"Custom\" # Task-specific variables self . command = command self . container = container self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.Custom.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 630 631 632 633 634 635 636 637 638 639 def run ( self ): \"\"\" Run a Task. \"\"\" # Run the task self . _run_task ( self . task_name , command = self . command , container_override = self . container , device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.EasyMD","text":"Bases: Task Source code in ribbon_tasks/tasks.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 class EasyMD ( Task ): #\"command\": \"easymd run {input_file} --output {output_prefix} --duration {duration} --relax-duration {relax_duration} --output-frequency {output_frequency} {ligand_files} {forcefield_files} {water_model} {pH} {hydrogen_variants} {ionic_strength} {box_padding} {custom_bonds} {custom_angles} {custom_torsions} {minimize_only} {extra_args}\", def __init__ ( self , input_file , output_prefix , duration , relax_duration = 1 , output_frequency = 1 , ligand_files = [], forcefield_files = [ 'amber14-all.xml' , 'amber14/tip3p.xml' ], water_model = 'tip3p' , pH = 7.0 , hydrogen_variants = None , ionic_strength = 0.15 , box_padding = 1.0 , custom_bonds = [], custom_angles = [], custom_torsions = [], minimize_only = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_file (str): The input structure file. output_prefix (str): The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration (int): The duration of the simulation in nanoseconds. relax_duration (int): The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency (int): The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files (list): A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files (list): A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model (str): The water model to use. Default is 'tip3p'. pH (float): The pH of the system for protonation. Default is 7.0. hydrogen_variants (str): List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength (float): The ionic strength of the system in M. Default is 0.15 M. box_padding (float): The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds (list): List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only (bool): Whether to ONLY run a minimization, no simulation. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Returns: Outputs PDB, DCD files using the given output_prefix. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"EasyMD\" # Your arguments here: self . input_file = input_file self . output_prefix = output_prefix self . duration = duration self . relax_duration = relax_duration self . output_frequency = output_frequency self . ligand_files = \"\" . join ([ f \" -l { ligand } \" for ligand in ligand_files ]) self . forcefield_files = \" \" . join ([ f \" -f { forcefield } \" for forcefield in forcefield_files ]) self . water_model = water_model self . pH = pH self . hydrogen_variants = \" \" . join ([ f \" -hv { variant } \" for variant in hydrogen_variants ]) if hydrogen_variants else \"\" self . ionic_strength = ionic_strength self . box_padding = box_padding self . custom_bonds = \" \" . join ([ f \" -cb { bond } \" for bond in custom_bonds ]) self . custom_angles = \" \" . join ([ f \" -ca { angle } \" for angle in custom_angles ]) self . custom_torsions = \" \" . join ([ f \" -ct { torsion } \" for torsion in custom_torsions ]) self . minimize_only = \"--minimize-only\" if minimize_only else \"\" self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: Path ( self . output_prefix ) . parent . mkdir ( parents = True , exist_ok = True ) # Run the task: self . _run_task ( self . task_name , input_file = self . input_file , output_prefix = str ( self . output_prefix ), duration = self . duration , relax_duration = self . relax_duration , output_frequency = self . output_frequency , ligand_files = self . ligand_files , forcefield_files = self . forcefield_files , water_model = self . water_model , pH = self . pH , hydrogen_variants = self . hydrogen_variants , ionic_strength = self . ionic_strength , box_padding = self . box_padding , custom_bonds = self . custom_bonds , custom_angles = self . custom_angles , custom_torsions = self . custom_torsions , minimize_only = self . minimize_only , extra_args = self . extra_args , device = self . device ) return","title":"EasyMD"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.EasyMD.__init__","text":"Initialize a RFDiffusionAA task. Parameters: input_file ( str ) \u2013 The input structure file. output_prefix ( str ) \u2013 The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration ( int ) \u2013 The duration of the simulation in nanoseconds. relax_duration ( int , default: 1 ) \u2013 The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency ( int , default: 1 ) \u2013 The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files ( list , default: [] ) \u2013 A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files ( list , default: ['amber14-all.xml', 'amber14/tip3p.xml'] ) \u2013 A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model ( str , default: 'tip3p' ) \u2013 The water model to use. Default is 'tip3p'. pH ( float , default: 7.0 ) \u2013 The pH of the system for protonation. Default is 7.0. hydrogen_variants ( str , default: None ) \u2013 List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength ( float , default: 0.15 ) \u2013 The ionic strength of the system in M. Default is 0.15 M. box_padding ( float , default: 1.0 ) \u2013 The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds ( list , default: [] ) \u2013 List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles ( list , default: [] ) \u2013 List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions ( list , default: [] ) \u2013 List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only ( bool , default: False ) \u2013 Whether to ONLY run a minimization, no simulation. Default is False. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Returns: \u2013 Outputs PDB, DCD files using the given output_prefix. Source code in ribbon_tasks/tasks.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def __init__ ( self , input_file , output_prefix , duration , relax_duration = 1 , output_frequency = 1 , ligand_files = [], forcefield_files = [ 'amber14-all.xml' , 'amber14/tip3p.xml' ], water_model = 'tip3p' , pH = 7.0 , hydrogen_variants = None , ionic_strength = 0.15 , box_padding = 1.0 , custom_bonds = [], custom_angles = [], custom_torsions = [], minimize_only = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_file (str): The input structure file. output_prefix (str): The prefix for the output files. (Output files will be named [prefix].pdb and [prefix].dcd, etc). duration (int): The duration of the simulation in nanoseconds. relax_duration (int): The duration of the relaxation phase in nanoseconds. Default is 1 ns. output_frequency (int): The frequency of output frames in nanoseconds. Default is 1 ns. ligand_files (list): A list of ligand SDF files for assigning bond orders and protons to ligands in the input structure. Default is no ligands added. forcefield_files (list): A list of forcefield files to use. Default is ['amber14-all.xml', 'amber14/tip3p.xml']. water_model (str): The water model to use. Default is 'tip3p'. pH (float): The pH of the system for protonation. Default is 7.0. hydrogen_variants (str): List of hydrogen variants to use. Specify the chain and residue number, then the variant. [\"A:13=HIE\", \"B:98=ASH\", ...]. ionic_strength (float): The ionic strength of the system in M. Default is 0.15 M. box_padding (float): The padding to add to the box size in nm. Default is 1.0 nm. custom_bonds (list): List of custom harmonic bonds to add. Specify the two atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/(mol*A^2)), then the target distance (units A). [\"A:99:CG,B:99:CG,10.0,2.0\", ... ] custom_angles (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,10.0,180\", ... ] custom_torsions (list): List of custom harmonic angles to add. Specify the three atoms in the form 'chain_id:residue_id:atom_name', then the k-value (units kcal/mol), the periodicity, and the phase value (units DEGREES). E.g. [\"A:99:CG,B:99:CG,C:99:CG,D:1:H6,10.0,1,180\", ... ] minimize_only (bool): Whether to ONLY run a minimization, no simulation. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Returns: Outputs PDB, DCD files using the given output_prefix. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"EasyMD\" # Your arguments here: self . input_file = input_file self . output_prefix = output_prefix self . duration = duration self . relax_duration = relax_duration self . output_frequency = output_frequency self . ligand_files = \"\" . join ([ f \" -l { ligand } \" for ligand in ligand_files ]) self . forcefield_files = \" \" . join ([ f \" -f { forcefield } \" for forcefield in forcefield_files ]) self . water_model = water_model self . pH = pH self . hydrogen_variants = \" \" . join ([ f \" -hv { variant } \" for variant in hydrogen_variants ]) if hydrogen_variants else \"\" self . ionic_strength = ionic_strength self . box_padding = box_padding self . custom_bonds = \" \" . join ([ f \" -cb { bond } \" for bond in custom_bonds ]) self . custom_angles = \" \" . join ([ f \" -ca { angle } \" for angle in custom_angles ]) self . custom_torsions = \" \" . join ([ f \" -ct { torsion } \" for torsion in custom_torsions ]) self . minimize_only = \"--minimize-only\" if minimize_only else \"\" self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.EasyMD.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: Path ( self . output_prefix ) . parent . mkdir ( parents = True , exist_ok = True ) # Run the task: self . _run_task ( self . task_name , input_file = self . input_file , output_prefix = str ( self . output_prefix ), duration = self . duration , relax_duration = self . relax_duration , output_frequency = self . output_frequency , ligand_files = self . ligand_files , forcefield_files = self . forcefield_files , water_model = self . water_model , pH = self . pH , hydrogen_variants = self . hydrogen_variants , ionic_strength = self . ionic_strength , box_padding = self . box_padding , custom_bonds = self . custom_bonds , custom_angles = self . custom_angles , custom_torsions = self . custom_torsions , minimize_only = self . minimize_only , extra_args = self . extra_args , device = self . device ) return","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.FastRelax","text":"Bases: Task Source code in ribbon_tasks/tasks.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class FastRelax ( Task ): def __init__ ( self , output_dir , pdb_input_file = None , pdb_input_dir = None , device = 'cpu' ): \"\"\" Initialize a FastRelax task. Args: output_dir (str): The directory to save the output files. pdb_input_file (str, optional): Path to a single PDB file. Default is None. pdb_input_dir (str, optional): Path to a directory containing PDB files. Default is None. device (str): The device to run the task on. Default is 'cpu'. Raises: ValueError: If neither pdb_input_file nor pdb_input_dir is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"FastRelax\" # Task-specific variables if pdb_input_file is None and pdb_input_dir is None : raise ValueError ( 'Must specify either pdb_input_file or pdb_input_dir' ) self . output_dir = make_directory ( output_dir ) self . pdb_input_file = pdb_input_file self . pdb_input_dir = pdb_input_dir self . device = device def run ( self ): \"\"\" Run a Task. \"\"\" # Handle input files if self . pdb_input_file is not None : temp_dir = tempfile . mkdtemp () shutil . copy ( self . pdb_input_file , temp_dir ) pdb_input_dir = temp_dir else : pdb_input_dir = self . pdb_input_dir # Prepare PDB files pdb_list = list_files ( pdb_input_dir , '.pdb' ) pdb_string = \" \" . join ( map ( str , pdb_list )) + \" \" # Run the task self . _run_task ( self . task_name , pdb_string = pdb_string , output_dir = str ( self . output_dir ), device = self . device )","title":"FastRelax"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.FastRelax.__init__","text":"Initialize a FastRelax task. Parameters: output_dir ( str ) \u2013 The directory to save the output files. pdb_input_file ( str , default: None ) \u2013 Path to a single PDB file. Default is None. pdb_input_dir ( str , default: None ) \u2013 Path to a directory containing PDB files. Default is None. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. Raises: ValueError \u2013 If neither pdb_input_file nor pdb_input_dir is specified. Source code in ribbon_tasks/tasks.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , output_dir , pdb_input_file = None , pdb_input_dir = None , device = 'cpu' ): \"\"\" Initialize a FastRelax task. Args: output_dir (str): The directory to save the output files. pdb_input_file (str, optional): Path to a single PDB file. Default is None. pdb_input_dir (str, optional): Path to a directory containing PDB files. Default is None. device (str): The device to run the task on. Default is 'cpu'. Raises: ValueError: If neither pdb_input_file nor pdb_input_dir is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"FastRelax\" # Task-specific variables if pdb_input_file is None and pdb_input_dir is None : raise ValueError ( 'Must specify either pdb_input_file or pdb_input_dir' ) self . output_dir = make_directory ( output_dir ) self . pdb_input_file = pdb_input_file self . pdb_input_dir = pdb_input_dir self . device = device","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.FastRelax.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def run ( self ): \"\"\" Run a Task. \"\"\" # Handle input files if self . pdb_input_file is not None : temp_dir = tempfile . mkdtemp () shutil . copy ( self . pdb_input_file , temp_dir ) pdb_input_dir = temp_dir else : pdb_input_dir = self . pdb_input_dir # Prepare PDB files pdb_list = list_files ( pdb_input_dir , '.pdb' ) pdb_string = \" \" . join ( map ( str , pdb_list )) + \" \" # Run the task self . _run_task ( self . task_name , pdb_string = pdb_string , output_dir = str ( self . output_dir ), device = self . device )","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.LigandMPNN","text":"Bases: Task Source code in ribbon_tasks/tasks.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class LigandMPNN ( Task ): def __init__ ( self , output_dir , structure_list , num_designs = 1 , device = 'cpu' , extra_args = \"\" ): \"\"\" Initialize a LigandMPNN task. Args: output_dir (str): The directory to save the output files. structure_list (list): A list of pdb or cif files to use as input structures. num_designs (int): The number of designs to generate per input structure. device (str): The device to run the task on. Default is 'cpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"LigandMPNN\" # Your arguments here: self . output_dir = output_dir self . structure_list = structure_list self . num_designs = num_designs def run ( self ): \"\"\" Run a Task. \"\"\" ###### HELPER FUNCTIONS ####### def split_ligandmpnn_fasta ( fasta_file , split_output_dir ): # Each LigandMPNN input produces a FASTA with multiple outputs as > lines. Each line has 1 or more chains separated by ':'. # Here, we separate each output into it's own FASTA file, with chains as separate > lines. split_output_dir . mkdir ( parents = True , exist_ok = True ) with open ( fasta_file ) as f : # Skip the first two lines (original input) lines = f . readlines ()[ 2 :] for i in range ( 0 , len ( lines ), 2 ): if not lines [ i ] . startswith ( '>' ): continue name = lines [ i ] . strip () chains = lines [ i + 1 ] . strip () . split ( ':' ) index = 0 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' # Increment the index to avoid overwriting existing files while output_path . exists (): index += 1 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' print ( f 'Writing to { output_path } ' ) with open ( output_path , 'w' ) as g : for chain_index , chain in enumerate ( chains ): name_with_chain = f \" { name . split ( ',' )[ 0 ] } _ { chain_index } \" + ', ' + ',' . join ( name . split ( ',' )[ 1 :]) # Add chain to name g . write ( f ' { name_with_chain } \\n { chain } \\n ' ) # Make directories: self . output_dir = make_directory ( self . output_dir ) # Then, write out the files within pdb_input_dir to a json file: #pdb_input_json = self.output_dir / 'pdb_input.json' # Make a temp file for the json: pdb_input_json = tempfile . NamedTemporaryFile ( delete = False ) . name with open ( pdb_input_json , 'w' ) as f : json . dump ( self . structure_list , f ) # Run the task: self . _run_task ( self . task_name , pdb_input_json = pdb_input_json , output_dir = self . output_dir , num_designs = self . num_designs , extra_args = self . extra_args , device = self . device ) # Split the FASTA files: for file in ( self . output_dir / 'seqs' ) . iterdir (): print ( f 'Splitting { file } ' ) split_ligandmpnn_fasta ( file , self . output_dir / 'seqs_split' ) return","title":"LigandMPNN"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.LigandMPNN.__init__","text":"Initialize a LigandMPNN task. Parameters: output_dir ( str ) \u2013 The directory to save the output files. structure_list ( list ) \u2013 A list of pdb or cif files to use as input structures. num_designs ( int , default: 1 ) \u2013 The number of designs to generate per input structure. device ( str , default: 'cpu' ) \u2013 The device to run the task on. Default is 'cpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Returns: \u2013 None \u2013 Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. Source code in ribbon_tasks/tasks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , output_dir , structure_list , num_designs = 1 , device = 'cpu' , extra_args = \"\" ): \"\"\" Initialize a LigandMPNN task. Args: output_dir (str): The directory to save the output files. structure_list (list): A list of pdb or cif files to use as input structures. num_designs (int): The number of designs to generate per input structure. device (str): The device to run the task on. Default is 'cpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs the following directories: output_dir: - backbones: The generated backbones - packed: The packed structures, including sidechains - sequences: The generated sequences as FASTA files. Multiple chains are separated by ':'. Each line is a different design. - seqs_split: The sequences split into separate FASTA files, one per design. Each line is a different chain. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"LigandMPNN\" # Your arguments here: self . output_dir = output_dir self . structure_list = structure_list self . num_designs = num_designs","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.LigandMPNN.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def run ( self ): \"\"\" Run a Task. \"\"\" ###### HELPER FUNCTIONS ####### def split_ligandmpnn_fasta ( fasta_file , split_output_dir ): # Each LigandMPNN input produces a FASTA with multiple outputs as > lines. Each line has 1 or more chains separated by ':'. # Here, we separate each output into it's own FASTA file, with chains as separate > lines. split_output_dir . mkdir ( parents = True , exist_ok = True ) with open ( fasta_file ) as f : # Skip the first two lines (original input) lines = f . readlines ()[ 2 :] for i in range ( 0 , len ( lines ), 2 ): if not lines [ i ] . startswith ( '>' ): continue name = lines [ i ] . strip () chains = lines [ i + 1 ] . strip () . split ( ':' ) index = 0 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' # Increment the index to avoid overwriting existing files while output_path . exists (): index += 1 output_path = split_output_dir / f ' { fasta_file . stem } _ { index } .fasta' print ( f 'Writing to { output_path } ' ) with open ( output_path , 'w' ) as g : for chain_index , chain in enumerate ( chains ): name_with_chain = f \" { name . split ( ',' )[ 0 ] } _ { chain_index } \" + ', ' + ',' . join ( name . split ( ',' )[ 1 :]) # Add chain to name g . write ( f ' { name_with_chain } \\n { chain } \\n ' ) # Make directories: self . output_dir = make_directory ( self . output_dir ) # Then, write out the files within pdb_input_dir to a json file: #pdb_input_json = self.output_dir / 'pdb_input.json' # Make a temp file for the json: pdb_input_json = tempfile . NamedTemporaryFile ( delete = False ) . name with open ( pdb_input_json , 'w' ) as f : json . dump ( self . structure_list , f ) # Run the task: self . _run_task ( self . task_name , pdb_input_json = pdb_input_json , output_dir = self . output_dir , num_designs = self . num_designs , extra_args = self . extra_args , device = self . device ) # Split the FASTA files: for file in ( self . output_dir / 'seqs' ) . iterdir (): print ( f 'Splitting { file } ' ) split_ligandmpnn_fasta ( file , self . output_dir / 'seqs_split' ) return","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RFDiffusionAA","text":"Bases: Task Source code in ribbon_tasks/tasks.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 class RFDiffusionAA ( Task ): def __init__ ( self , input_structure , output_dir , contig_map , num_designs = 1 , total_length = 'null' , ligand = 'null' , diffuser_steps = 200 , deterministic = False , design_startnum = 0 , force = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_structure (str): The input structure file. output_dir (str): The directory to save the output files. contig_map (str): The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs (int): The number of designs to generate per input structure. total_length (str): The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand (str): The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps (int): The number of steps to run the diffuser for. Default is 200. deterministic (bool): Whether to use a deterministic seed for the diffuser. Default is False. design_startnum (int): The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force (bool): Whether to overwrite existing output files. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs designs in the output_dir. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"RFDiffusionAA\" # Your arguments here: self . input_structure = input_structure self . output_dir = output_dir self . contig_map = contig_map self . num_designs = num_designs self . total_length = total_length self . ligand = ligand self . diffuser_steps = diffuser_steps self . deterministic = deterministic self . design_startnum = design_startnum self . force = force # we should have a final length flag for config.length def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: self . output_dir = make_directory ( self . output_dir ) # Convert the output_dir to a prefix: output_prefix = Path ( self . output_dir ) / 'design' # Run the task: self . _run_task ( self . task_name , input_structure = self . input_structure , output_prefix = str ( output_prefix ), # we provide a prefix (e.g. ./out/sample) instead of dir (e.g. ./out) contig_map = self . contig_map , num_designs = self . num_designs , total_length = self . total_length , ligand = self . ligand , diffuser_steps = self . diffuser_steps , deterministic = self . deterministic , design_startnum = self . design_startnum , cautious = not self . force , # If force is True, then we overwrite existing files extra_args = self . extra_args , device = self . device ) return","title":"RFDiffusionAA"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RFDiffusionAA.__init__","text":"Initialize a RFDiffusionAA task. Parameters: input_structure ( str ) \u2013 The input structure file. output_dir ( str ) \u2013 The directory to save the output files. contig_map ( str ) \u2013 The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs ( int , default: 1 ) \u2013 The number of designs to generate per input structure. total_length ( str , default: 'null' ) \u2013 The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand ( str , default: 'null' ) \u2013 The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps ( int , default: 200 ) \u2013 The number of steps to run the diffuser for. Default is 200. deterministic ( bool , default: False ) \u2013 Whether to use a deterministic seed for the diffuser. Default is False. design_startnum ( int , default: 0 ) \u2013 The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force ( bool , default: False ) \u2013 Whether to overwrite existing output files. Default is False. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Returns: \u2013 None \u2013 Outputs designs in the output_dir. Source code in ribbon_tasks/tasks.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def __init__ ( self , input_structure , output_dir , contig_map , num_designs = 1 , total_length = 'null' , ligand = 'null' , diffuser_steps = 200 , deterministic = False , design_startnum = 0 , force = False , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RFDiffusionAA task. Args: input_structure (str): The input structure file. output_dir (str): The directory to save the output files. contig_map (str): The contig map. This is formatted as a hydra list. E.g. \"[150-150]\". num_designs (int): The number of designs to generate per input structure. total_length (str): The total length of the protein (e.g. \"150-150\"). Default is 'null'. ligand (str): The residue ID of the ligand to dock. (e.g. \"OQO\"). Default is 'null'. diffuser_steps (int): The number of steps to run the diffuser for. Default is 200. deterministic (bool): Whether to use a deterministic seed for the diffuser. Default is False. design_startnum (int): The starting number for the design output files. Useful for batching jobs in the same out directory. Default is 0. force (bool): Whether to overwrite existing output files. Default is False. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Returns: None Outputs designs in the output_dir. \"\"\" # Initialize the Task class super () . __init__ ( device = device , extra_args = extra_args ) # This Task name matches the name in the tasks.json file self . task_name = \"RFDiffusionAA\" # Your arguments here: self . input_structure = input_structure self . output_dir = output_dir self . contig_map = contig_map self . num_designs = num_designs self . total_length = total_length self . ligand = ligand self . diffuser_steps = diffuser_steps self . deterministic = deterministic self . design_startnum = design_startnum self . force = force","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RFDiffusionAA.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def run ( self ): \"\"\" Run a Task. \"\"\" # Make directories: self . output_dir = make_directory ( self . output_dir ) # Convert the output_dir to a prefix: output_prefix = Path ( self . output_dir ) / 'design' # Run the task: self . _run_task ( self . task_name , input_structure = self . input_structure , output_prefix = str ( output_prefix ), # we provide a prefix (e.g. ./out/sample) instead of dir (e.g. ./out) contig_map = self . contig_map , num_designs = self . num_designs , total_length = self . total_length , ligand = self . ligand , diffuser_steps = self . diffuser_steps , deterministic = self . deterministic , design_startnum = self . design_startnum , cautious = not self . force , # If force is True, then we overwrite existing files extra_args = self . extra_args , device = self . device ) return","title":"run"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RaptorXSingle","text":"Bases: Task Source code in ribbon_tasks/tasks.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 class RaptorXSingle ( Task ): def __init__ ( self , fasta_file_or_dir , output_dir = '.' , param = 'RaptorX-Single-ESM1b.pt' , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RaptorXSingle task. Args: fasta_file_or_dir (str): The FASTA file or directory containing multiple FASTA files. output_dir (str): The directory to save the output files. Default is '.'. param (str): The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Raises: ValueError: If an invalid param is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"RaptorXSingle\" # Task-specific variables self . fasta_file = fasta_file_or_dir self . output_dir = output_dir self . param = 'RaptorX-Single/params/' + param #This is the directory where the params are stored self . extra_args = extra_args self . device = device if device == 'gpu' : self . device_id = '0' elif device == 'cpu' : self . device_id = '-1' else : self . device_id = str ( device ) self . device = 'cpu' if device == '-1' else 'gpu' # Check inputs: valid_param_list = [ 'RaptorX-Single-ESM1b.pt' , 'RaptorX-Single-ESM1v.pt' , 'RaptorX-Single-ProtTrans.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt' , 'RaptorX-Single-ESM1b-Ab.pt' , 'RaptorX-Single-ESM1v-Ab.pt' , 'RaptorX-Single-ProtTrans-Ab.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt' ] if param not in valid_param_list : raise ValueError ( f 'Invalid param: { param } . Must be one of { valid_param_list } ' ) def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # \"python RaptorX-Single/pred.py {fasta_file} RaptorX-Single/params/{param} --plm_param_dir RaptorX-Single/params/ --out_dir {output_dir} --device {device} {extra_args}\", # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , param = self . param , output_dir = str ( self . output_dir ), device = self . device , device_id = self . device_id , extra_args = self . extra_args )","title":"RaptorXSingle"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RaptorXSingle.__init__","text":"Initialize a RaptorXSingle task. Parameters: fasta_file_or_dir ( str ) \u2013 The FASTA file or directory containing multiple FASTA files. output_dir ( str , default: '.' ) \u2013 The directory to save the output files. Default is '.'. param ( str , default: 'RaptorX-Single-ESM1b.pt' ) \u2013 The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device ( str , default: 'gpu' ) \u2013 The device to run the task on. Default is 'gpu'. extra_args ( str , default: '' ) \u2013 Additional arguments for the task. Default is an empty string. Raises: ValueError \u2013 If an invalid param is specified. Source code in ribbon_tasks/tasks.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def __init__ ( self , fasta_file_or_dir , output_dir = '.' , param = 'RaptorX-Single-ESM1b.pt' , device = 'gpu' , extra_args = \"\" ): \"\"\" Initialize a RaptorXSingle task. Args: fasta_file_or_dir (str): The FASTA file or directory containing multiple FASTA files. output_dir (str): The directory to save the output files. Default is '.'. param (str): The checkpoint to use. Default is 'RaptorX-Single-ESM1b.pt'. device (str): The device to run the task on. Default is 'gpu'. extra_args (str): Additional arguments for the task. Default is an empty string. Raises: ValueError: If an invalid param is specified. \"\"\" # Initialize the Task class super () . __init__ () # This Task name matches the name in the tasks.json file self . task_name = \"RaptorXSingle\" # Task-specific variables self . fasta_file = fasta_file_or_dir self . output_dir = output_dir self . param = 'RaptorX-Single/params/' + param #This is the directory where the params are stored self . extra_args = extra_args self . device = device if device == 'gpu' : self . device_id = '0' elif device == 'cpu' : self . device_id = '-1' else : self . device_id = str ( device ) self . device = 'cpu' if device == '-1' else 'gpu' # Check inputs: valid_param_list = [ 'RaptorX-Single-ESM1b.pt' , 'RaptorX-Single-ESM1v.pt' , 'RaptorX-Single-ProtTrans.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans.pt' , 'RaptorX-Single-ESM1b-Ab.pt' , 'RaptorX-Single-ESM1v-Ab.pt' , 'RaptorX-Single-ProtTrans-Ab.pt' , 'RaptorX-Single-ESM1b-ESM1v-ProtTrans-Ab.pt' ] if param not in valid_param_list : raise ValueError ( f 'Invalid param: { param } . Must be one of { valid_param_list } ' )","title":"__init__"},{"location":"api/ribbon_tasks/#ribbon_tasks.tasks.RaptorXSingle.run","text":"Run a Task. Source code in ribbon_tasks/tasks.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def run ( self ): \"\"\" Run a Task. \"\"\" # Make the directory: self . output_dir = make_directory ( self . output_dir ) # \"python RaptorX-Single/pred.py {fasta_file} RaptorX-Single/params/{param} --plm_param_dir RaptorX-Single/params/ --out_dir {output_dir} --device {device} {extra_args}\", # Run the task self . _run_task ( self . task_name , fasta_file = self . fasta_file , param = self . param , output_dir = str ( self . output_dir ), device = self . device , device_id = self . device_id , extra_args = self . extra_args )","title":"run"},{"location":"usage/getting_started/","text":"How to use Ribbon-Tasks Warning \ud83d\udea7 This Page is Under Construction! \ud83d\udea7","title":"How to use Ribbon-Tasks"},{"location":"usage/getting_started/#how-to-use-ribbon-tasks","text":"Warning \ud83d\udea7 This Page is Under Construction! \ud83d\udea7","title":"How to use Ribbon-Tasks"}]}